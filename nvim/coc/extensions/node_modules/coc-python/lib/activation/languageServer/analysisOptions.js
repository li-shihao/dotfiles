// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const inversify_1 = require("inversify");
const path = __importStar(require("path"));
// import { CancellationToken, CompletionContext, ConfigurationChangeEvent, Disposable, Event, Emitter, OutputChannel, Position, TextDocument } from 'coc.nvim'
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const types_1 = require("../../common/application/types");
const constants_1 = require("../../common/constants");
const logger_1 = require("../../common/logger");
const types_2 = require("../../common/types");
const decorators_1 = require("../../common/utils/decorators");
const types_3 = require("../../common/variables/types");
const contracts_1 = require("../../interpreter/contracts");
const types_4 = require("../types");
const function_1 = require("../../common/function");
let LanguageServerAnalysisOptions = class LanguageServerAnalysisOptions {
    constructor(context, envVarsProvider, configuration, workspace, surveyBanner, interpreterService, output, pathUtils, languageServerFolderService) {
        this.context = context;
        this.envVarsProvider = envVarsProvider;
        this.configuration = configuration;
        this.workspace = workspace;
        this.surveyBanner = surveyBanner;
        this.interpreterService = interpreterService;
        this.output = output;
        this.pathUtils = pathUtils;
        this.languageServerFolderService = languageServerFolderService;
        this.envPythonPath = '';
        this.excludedFiles = [];
        this.typeshedPaths = [];
        this.disposables = [];
        this.languageServerFolder = '';
        this.didChange = new vscode_languageserver_protocol_1.Emitter();
    }
    async initialize(resource) {
        this.resource = resource;
        this.languageServerFolder = await this.languageServerFolderService.getLanguageServerFolderName();
        let disposable = this.workspace.onDidChangeConfiguration(this.onSettingsChangedHandler, this);
        this.disposables.push(disposable);
        disposable = this.interpreterService.onDidChangeInterpreter(() => this.didChange.fire(), this);
        this.disposables.push(disposable);
        disposable = this.envVarsProvider.onDidEnvironmentVariablesChange(this.onEnvVarChange, this);
        this.disposables.push(disposable);
    }
    get onDidChange() {
        return this.didChange.event;
    }
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.didChange.dispose();
    }
    async getAnalysisOptions() {
        const properties = {};
        const interpreterInfo = await this.interpreterService.getActiveInterpreter(this.resource);
        if (!interpreterInfo) {
            // tslint:disable-next-line:no-suspicious-comment
            // TODO: How do we handle this?  It is pretty unlikely...
            throw Error('did not find an active interpreter');
        }
        // tslint:disable-next-line:no-string-literal
        properties['InterpreterPath'] = interpreterInfo.path;
        const version = interpreterInfo.version;
        if (version) {
            // tslint:disable-next-line:no-string-literal
            properties['Version'] = `${version.major}.${version.minor}.${version.patch}`;
        }
        else {
            logger_1.traceError('Unable to determine Python version. Analysis may be limited.');
        }
        let searchPaths = [];
        const settings = this.configuration.getSettings(this.resource);
        if (settings.autoComplete) {
            const extraPaths = settings.autoComplete.extraPaths;
            if (extraPaths && extraPaths.length > 0) {
                searchPaths.push(...extraPaths);
            }
        }
        // tslint:disable-next-line:no-string-literal
        properties['DatabasePath'] = path.resolve(this.context.storagePath, this.languageServerFolder);
        const vars = await this.envVarsProvider.getEnvironmentVariables();
        this.envPythonPath = vars.PYTHONPATH || '';
        if (this.envPythonPath !== '') {
            const paths = this.envPythonPath.split(this.pathUtils.delimiter).filter(item => item.trim().length > 0);
            searchPaths.push(...paths);
        }
        searchPaths = searchPaths.map(p => path.normalize(p));
        this.excludedFiles = this.getExcludedFiles();
        this.typeshedPaths = this.getTypeshedPaths();
        const documentSelector = [
            { scheme: 'file', language: constants_1.PYTHON_LANGUAGE },
            { scheme: 'untitled', language: constants_1.PYTHON_LANGUAGE }
        ];
        documentSelector[0].pattern = `${coc_nvim_1.workspace.rootPath}/**/*`;
        // Options to control the language client
        return {
            // Register the server for Python documents
            documentSelector,
            workspaceFolder: coc_nvim_1.workspace.workspaceFolder,
            synchronize: {
                configurationSection: constants_1.PYTHON_LANGUAGE
            },
            outputChannel: this.output,
            initializationOptions: {
                interpreter: {
                    properties
                },
                displayOptions: {
                    preferredFormat: 'markdown',
                    trimDocumentationLines: false,
                    maxDocumentationLineLength: 0,
                    trimDocumentationText: false,
                    maxDocumentationTextLength: 0
                },
                searchPaths,
                typeStubSearchPaths: this.typeshedPaths,
                excludeFiles: this.excludedFiles,
                testEnvironment: constants_1.isTestExecution(),
                analysisUpdates: true,
                traceLogging: true,
                asyncStartup: true
            },
            middleware: {
                provideCompletionItem: (document, position, context, token, next) => {
                    this.surveyBanner.showBanner().catch(function_1.emptyFn);
                    return next(document, position, context, token);
                }
            }
        };
    }
    getExcludedFiles() {
        const list = ['**/Lib/**', '**/site-packages/**'];
        this.getVsCodeExcludeSection('search.exclude', list);
        this.getVsCodeExcludeSection('files.exclude', list);
        this.getVsCodeExcludeSection('files.watcherExclude', list);
        this.getPythonExcludeSection(list);
        return list;
    }
    getVsCodeExcludeSection(setting, list) {
        const states = this.workspace.getConfiguration(setting);
        if (states) {
            Object.keys(states)
                .filter(k => (k.indexOf('*') >= 0 || k.indexOf('/') >= 0) && states[k])
                .forEach(p => list.push(p));
        }
    }
    getPythonExcludeSection(list) {
        const pythonSettings = this.configuration.getSettings(this.resource);
        const paths = pythonSettings && pythonSettings.linting ? pythonSettings.linting.ignorePatterns : undefined;
        if (paths && Array.isArray(paths)) {
            paths
                .filter(p => p && p.length > 0)
                .forEach(p => list.push(p));
        }
    }
    getTypeshedPaths() {
        const settings = this.configuration.getSettings(this.resource);
        return settings.analysis.typeshedPaths && settings.analysis.typeshedPaths.length > 0
            ? settings.analysis.typeshedPaths
            : [path.join(this.context.extensionPath, this.languageServerFolder, 'Typeshed')];
    }
    async onSettingsChangedHandler(e) {
        if (e && !e.affectsConfiguration('python')) {
            return;
        }
        this.onSettingsChanged();
    }
    onSettingsChanged() {
        this.notifyIfSettingsChanged().catch(function_1.emptyFn);
    }
    async notifyIfSettingsChanged() {
        const excludedFiles = this.getExcludedFiles();
        await this.notifyIfValuesHaveChanged(this.excludedFiles, excludedFiles);
        const typeshedPaths = this.getTypeshedPaths();
        await this.notifyIfValuesHaveChanged(this.typeshedPaths, typeshedPaths);
    }
    async notifyIfValuesHaveChanged(oldArray, newArray) {
        if (newArray.length !== oldArray.length) {
            this.didChange.fire();
            return;
        }
        for (let i = 0; i < oldArray.length; i += 1) {
            if (oldArray[i] !== newArray[i]) {
                this.didChange.fire();
                return;
            }
        }
    }
    onEnvVarChange() {
        this.notifyifEnvPythonPathChanged().catch(function_1.emptyFn);
    }
    async notifyifEnvPythonPathChanged() {
        const vars = await this.envVarsProvider.getEnvironmentVariables();
        const envPythonPath = vars.PYTHONPATH;
        if (this.envPythonPath !== envPythonPath) {
            this.didChange.fire();
        }
    }
};
__decorate([
    logger_1.traceDecorators.error('Failed to get analysis options')
], LanguageServerAnalysisOptions.prototype, "getAnalysisOptions", null);
__decorate([
    decorators_1.debounce(1000)
], LanguageServerAnalysisOptions.prototype, "onSettingsChanged", null);
__decorate([
    logger_1.traceDecorators.verbose('Changes in python settings detected in analysis options')
], LanguageServerAnalysisOptions.prototype, "notifyIfSettingsChanged", null);
__decorate([
    decorators_1.debounce(1000)
], LanguageServerAnalysisOptions.prototype, "onEnvVarChange", null);
LanguageServerAnalysisOptions = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_2.IExtensionContext)),
    __param(1, inversify_1.inject(types_3.IEnvironmentVariablesProvider)),
    __param(2, inversify_1.inject(types_2.IConfigurationService)),
    __param(3, inversify_1.inject(types_1.IWorkspaceService)),
    __param(4, inversify_1.inject(types_2.IPythonExtensionBanner)), __param(4, inversify_1.named(types_2.BANNER_NAME_PROPOSE_LS)),
    __param(5, inversify_1.inject(contracts_1.IInterpreterService)),
    __param(6, inversify_1.inject(types_2.IOutputChannel)), __param(6, inversify_1.named(constants_1.STANDARD_OUTPUT_CHANNEL)),
    __param(7, inversify_1.inject(types_2.IPathUtils)),
    __param(8, inversify_1.inject(types_4.ILanguageServerFolderService))
], LanguageServerAnalysisOptions);
exports.LanguageServerAnalysisOptions = LanguageServerAnalysisOptions;
//# sourceMappingURL=analysisOptions.js.map