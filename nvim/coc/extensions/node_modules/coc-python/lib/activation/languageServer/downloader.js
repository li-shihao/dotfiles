// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const inversify_1 = require("inversify");
const path = __importStar(require("path"));
const coc_nvim_1 = require("coc.nvim");
const types_1 = require("../../common/application/types");
const constants_1 = require("../../common/constants");
const types_2 = require("../../common/platform/types");
const types_3 = require("../../common/types");
const async_1 = require("../../common/utils/async");
const localize_1 = require("../../common/utils/localize");
const stopWatch_1 = require("../../common/utils/stopWatch");
const types_4 = require("../types");
const function_1 = require("../../common/function");
// tslint:disable:no-require-imports no-any
const downloadFileExtension = '.nupkg';
let LanguageServerDownloader = class LanguageServerDownloader {
    constructor(platformData, output, httpClient, lsFolderService, appShell, fs) {
        this.platformData = platformData;
        this.output = output;
        this.httpClient = httpClient;
        this.lsFolderService = lsFolderService;
        this.appShell = appShell;
        this.fs = fs;
    }
    async getDownloadInfo() {
        return this.lsFolderService.getLatestLanguageServerVersion().then(item => item);
    }
    async downloadLanguageServer(destinationFolder) {
        const downloadInfo = await this.getDownloadInfo();
        const downloadUri = downloadInfo.uri;
        const lsVersion = downloadInfo.version.raw;
        const timer = new stopWatch_1.StopWatch();
        let success = true;
        let localTempFilePath = '';
        try {
            localTempFilePath = await this.downloadFile(downloadUri, 'Downloading Microsoft Python Language Server... ');
        }
        catch (err) {
            this.output.appendLine(localize_1.LanguageService.downloadFailedOutputMessage());
            this.output.appendLine(err);
            success = false;
            this.showMessageAndOptionallyShowOutput(localize_1.LanguageService.lsFailedToDownload()).catch(function_1.emptyFn);
            throw new Error(err);
        }
        timer.reset();
        try {
            await this.unpackArchive(destinationFolder, localTempFilePath);
        }
        catch (err) {
            this.output.appendLine(localize_1.LanguageService.extractionFailedOutputMessage());
            this.output.appendLine(err);
            success = false;
            this.showMessageAndOptionallyShowOutput(localize_1.LanguageService.lsFailedToExtract()).catch(function_1.emptyFn);
            throw new Error(err);
        }
        finally {
            await this.fs.deleteFile(localTempFilePath);
        }
    }
    async showMessageAndOptionallyShowOutput(message) {
        coc_nvim_1.workspace.showMessage(message + ' checkout output for detail.', 'error');
    }
    async downloadFile(uri, title) {
        this.output.append(`Downloading ${uri}... `);
        const tempFile = await this.fs.createTemporaryFile(downloadFileExtension);
        let statusItem = coc_nvim_1.workspace.createStatusBarItem(0, { progress: true });
        statusItem.text = `Downloading ${uri}... `;
        const deferred = async_1.createDeferred();
        const fileStream = this.fs.createWriteStream(tempFile.filePath);
        fileStream.on('finish', () => {
            fileStream.close();
        }).on('error', err => {
            tempFile.dispose();
            deferred.reject(err);
        });
        statusItem.show();
        const req = await this.httpClient.downloadFile(uri);
        req.on('response', response => {
            if (response.statusCode !== 200) {
                const error = new Error(`Failed with status ${response.statusCode}, ${response.statusMessage}, Uri ${uri}`);
                deferred.reject(error);
                throw error;
            }
        });
        const requestProgress = require('request-progress');
        requestProgress(req)
            .on('progress', (state) => {
            // https://www.npmjs.com/package/request-progress
            const received = Math.round(state.size.transferred / 1024);
            const total = Math.round(state.size.total / 1024);
            const percentage = Math.round(100 * state.percent);
            statusItem.text = `${title}${received} of ${total} KB (${percentage}%)`;
        })
            .on('error', (err) => {
            deferred.reject(err);
            statusItem.dispose();
        })
            .on('end', () => {
            statusItem.dispose();
            this.output.appendLine(localize_1.LanguageService.extractionCompletedOutputMessage());
            deferred.resolve();
        })
            .pipe(fileStream);
        await deferred.promise;
        return tempFile.filePath;
    }
    async unpackArchive(destinationFolder, tempFilePath) {
        this.output.append('Unpacking archive... ');
        const deferred = async_1.createDeferred();
        const title = 'Extracting files... ';
        let statusItem = coc_nvim_1.workspace.createStatusBarItem(0, { progress: true });
        statusItem.text = title;
        statusItem.show();
        // tslint:disable-next-line:no-require-imports no-var-requires
        const StreamZip = require('node-stream-zip');
        const zip = new StreamZip({
            file: tempFilePath,
            storeEntries: true
        });
        let totalFiles = 0;
        let extractedFiles = 0;
        zip.on('ready', async () => {
            totalFiles = zip.entriesCount;
            if (!await this.fs.directoryExists(destinationFolder)) {
                await this.fs.createDirectory(destinationFolder);
            }
            zip.extract(null, destinationFolder, (err) => {
                if (err) {
                    deferred.reject(err);
                }
                else {
                    deferred.resolve();
                }
                zip.close();
            });
        }).on('extract', () => {
            extractedFiles += 1;
            statusItem.text = `${title}${Math.round(100 * extractedFiles / totalFiles)}%`;
        }).on('error', (e) => {
            deferred.reject(e);
        });
        await deferred.promise;
        statusItem.dispose();
        // Set file to executable (nothing happens in Windows, as chmod has no definition there)
        const executablePath = path.join(destinationFolder, this.platformData.engineExecutableName);
        await this.fs.chmod(executablePath, '0755'); // -rwxrw-r--
        this.output.appendLine(localize_1.LanguageService.extractionDoneOutputMessage());
    }
};
LanguageServerDownloader = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_4.IPlatformData)),
    __param(1, inversify_1.inject(types_3.IOutputChannel)), __param(1, inversify_1.named(constants_1.STANDARD_OUTPUT_CHANNEL)),
    __param(2, inversify_1.inject(types_4.IHttpClient)),
    __param(3, inversify_1.inject(types_4.ILanguageServerFolderService)),
    __param(4, inversify_1.inject(types_1.IApplicationShell)),
    __param(5, inversify_1.inject(types_2.IFileSystem))
], LanguageServerDownloader);
exports.LanguageServerDownloader = LanguageServerDownloader;
//# sourceMappingURL=downloader.js.map