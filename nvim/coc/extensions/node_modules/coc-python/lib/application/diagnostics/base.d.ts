import { DiagnosticSeverity } from 'vscode-languageserver-protocol';
import { Resource } from '../../common/types';
import { IServiceContainer } from '../../ioc/types';
import { DiagnosticCodes } from './constants';
import { DiagnosticScope, IDiagnostic, IDiagnosticFilterService, IDiagnosticsService } from './types';
export declare abstract class BaseDiagnostic implements IDiagnostic {
    readonly code: DiagnosticCodes;
    readonly message: string;
    readonly severity: DiagnosticSeverity;
    readonly scope: DiagnosticScope;
    readonly resource: Resource;
    readonly invokeHandler: 'always' | 'default';
    constructor(code: DiagnosticCodes, message: string, severity: DiagnosticSeverity, scope: DiagnosticScope, resource: Resource, invokeHandler?: 'always' | 'default');
}
export declare abstract class BaseDiagnosticsService implements IDiagnosticsService {
    private readonly supportedDiagnosticCodes;
    protected serviceContainer: IServiceContainer;
    readonly runInBackground: Boolean;
    protected static handledDiagnosticCodeKeys: string[];
    protected readonly filterService: IDiagnosticFilterService;
    constructor(supportedDiagnosticCodes: string[], serviceContainer: IServiceContainer, runInBackground?: Boolean);
    abstract diagnose(resource: Resource): Promise<IDiagnostic[]>;
    handle(diagnostics: IDiagnostic[]): Promise<void>;
    canHandle(diagnostic: IDiagnostic): Promise<boolean>;
    protected abstract onHandle(diagnostics: IDiagnostic[]): Promise<void>;
    /**
     * Returns a key used to keep track of whether a diagnostic was handled or not.
     * So as to prevent handling/displaying messages multiple times for the same diagnostic.
     *
     * @protected
     * @param {IDiagnostic} diagnostic
     * @returns {string}
     * @memberof BaseDiagnosticsService
     */
    protected getDiagnosticsKey(diagnostic: IDiagnostic): string;
}
