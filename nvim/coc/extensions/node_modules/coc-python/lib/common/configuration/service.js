"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const inversify_1 = require("inversify");
const coc_nvim_1 = require("coc.nvim");
const types_1 = require("../../interpreter/autoSelection/types");
const types_2 = require("../../ioc/types");
const types_3 = require("../application/types");
const configSettings_1 = require("../configSettings");
const types_4 = require("../types");
let ConfigurationService = class ConfigurationService {
    constructor(serviceContainer) {
        this.serviceContainer = serviceContainer;
        this.workspaceService = this.serviceContainer.get(types_3.IWorkspaceService);
        this.stateFactory = this.serviceContainer.get(types_4.IPersistentStateFactory);
    }
    getSettings(resource) {
        const InterpreterAutoSelectionService = this.serviceContainer.get(types_1.IInterpreterAutoSeletionProxyService);
        return configSettings_1.PythonSettings.getInstance(resource, InterpreterAutoSelectionService, this.stateFactory, this.workspaceService);
    }
    async updateSectionSetting(section, setting, value, resource, configTarget) {
        const defaultSetting = {
            uri: resource,
            target: configTarget || coc_nvim_1.ConfigurationTarget.Workspace
        };
        let settingsInfo = defaultSetting;
        if (section === 'python' && configTarget !== coc_nvim_1.ConfigurationTarget.Global) {
            settingsInfo = configSettings_1.PythonSettings.getSettingsUriAndTarget(resource, this.workspaceService);
        }
        const configSection = coc_nvim_1.workspace.getConfiguration(section, settingsInfo.uri ? settingsInfo.uri.toString() : null);
        const currentValue = configSection.inspect(setting);
        if (currentValue !== undefined &&
            ((settingsInfo.target === coc_nvim_1.ConfigurationTarget.Global && currentValue.globalValue === value) ||
                (settingsInfo.target === coc_nvim_1.ConfigurationTarget.Workspace && currentValue.workspaceValue === value))) {
            return;
        }
        configSection.update(setting, value, settingsInfo.target == coc_nvim_1.ConfigurationTarget.User);
        await this.verifySetting(configSection, settingsInfo.target, setting, value);
    }
    async updateSetting(setting, value, resource, configTarget) {
        return this.updateSectionSetting('python', setting, value, resource, configTarget);
    }
    isTestExecution() {
        return process.env.VSC_PYTHON_CI_TEST === '1';
    }
    async verifySetting(configSection, target, settingName, value) {
        if (this.isTestExecution()) {
            let retries = 0;
            do {
                const setting = configSection.inspect(settingName);
                if (!setting && value === undefined) {
                    break; // Both are unset
                }
                if (setting && value !== undefined) {
                    // Both specified
                    const actual = target === coc_nvim_1.ConfigurationTarget.Global
                        ? setting.globalValue
                        : target === coc_nvim_1.ConfigurationTarget.Workspace ? setting.workspaceValue : setting.workspaceValue;
                    if (actual === value) {
                        break;
                    }
                }
                // Wait for settings to get refreshed.
                // tslint:disable-next-line: no-inferred-empty-object-type
                await new Promise(resolve => setTimeout(resolve, 250));
                retries += 1;
            } while (retries < 20);
        }
    }
};
ConfigurationService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_2.IServiceContainer))
], ConfigurationService);
exports.ConfigurationService = ConfigurationService;
//# sourceMappingURL=service.js.map