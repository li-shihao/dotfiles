import { OutputChannel } from 'coc.nvim';
import Uri from 'vscode-uri';
import { IServiceContainer } from '../../ioc/types';
import { IApplicationShell } from '../application/types';
import { IConfigurationService, IInstaller, InstallerResponse, ModuleNamePurpose, Product } from '../types';
export { Product } from '../types';
export declare abstract class BaseInstaller {
    protected serviceContainer: IServiceContainer;
    protected outputChannel: OutputChannel;
    private static readonly PromptPromises;
    protected readonly appShell: IApplicationShell;
    protected readonly configService: IConfigurationService;
    private readonly productService;
    constructor(serviceContainer: IServiceContainer, outputChannel: OutputChannel);
    promptToInstall(product: Product, resource?: Uri): Promise<InstallerResponse>;
    install(product: Product, resource?: Uri): Promise<InstallerResponse>;
    isInstalled(product: Product, resource?: Uri): Promise<boolean | undefined>;
    protected abstract promptToInstallImplementation(product: Product, resource?: Uri): Promise<InstallerResponse>;
    protected getExecutableNameFromSettings(product: Product, resource?: Uri): string;
    protected isExecutableAModule(product: Product, resource?: Uri): Boolean;
}
export declare class CTagsInstaller extends BaseInstaller {
    constructor(serviceContainer: IServiceContainer, outputChannel: OutputChannel);
    install(_product: Product, _resource?: Uri): Promise<InstallerResponse>;
    protected promptToInstallImplementation(product: Product, resource?: Uri): Promise<InstallerResponse>;
}
export declare class FormatterInstaller extends BaseInstaller {
    protected promptToInstallImplementation(product: Product, resource?: Uri): Promise<InstallerResponse>;
}
export declare class LinterInstaller extends BaseInstaller {
    protected promptToInstallImplementation(product: Product, resource?: Uri): Promise<InstallerResponse>;
    /**
     * For installers that want to avoid prompting the user over and over, they can make use of a
     * persisted true/false value representing user responses to 'stop showing this prompt'. This method
     * gets the persisted value given the installer-defined key.
     *
     * @param key Key to use to get a persisted response value, each installer must define this for themselves.
     * @returns Boolean: The current state of the stored response key given.
     */
    protected getStoredResponse(key: string): boolean;
    /**
     * For installers that want to avoid prompting the user over and over, they can make use of a
     * persisted true/false value representing user responses to 'stop showing this prompt'. This
     * method will set that persisted value given the installer-defined key.
     *
     * @param key Key to use to get a persisted response value, each installer must define this for themselves.
     * @param value Boolean value to store for the user - if they choose to not be prompted again for instance.
     * @returns Boolean: The current state of the stored response key given.
     */
    private setStoredResponse;
}
export declare class TestFrameworkInstaller extends BaseInstaller {
    protected promptToInstallImplementation(product: Product, resource?: Uri): Promise<InstallerResponse>;
}
export declare class RefactoringLibraryInstaller extends BaseInstaller {
    protected promptToInstallImplementation(product: Product, resource?: Uri): Promise<InstallerResponse>;
}
export declare class ProductInstaller implements IInstaller {
    private serviceContainer;
    private outputChannel;
    private readonly productService;
    constructor(serviceContainer: IServiceContainer, outputChannel: OutputChannel);
    dispose(): void;
    promptToInstall(product: Product, resource?: Uri): Promise<InstallerResponse>;
    install(product: Product, resource?: Uri): Promise<InstallerResponse>;
    isInstalled(product: Product, resource?: Uri): Promise<boolean | undefined>;
    translateProductToModuleName(product: Product, purpose: ModuleNamePurpose): string;
    private createInstaller;
}
