"use strict";
// tslint:disable:max-classes-per-file max-classes-per-file
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const inversify_1 = require("inversify");
const os = __importStar(require("os"));
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const types_1 = require("../../ioc/types");
const types_2 = require("../application/types");
const constants_1 = require("../constants");
const types_3 = require("../platform/types");
const types_4 = require("../process/types");
const types_5 = require("../types");
const productNames_1 = require("./productNames");
const types_6 = require("./types");
var types_7 = require("../types");
exports.Product = types_7.Product;
const CTagsInsllationScript = os.platform() === 'darwin' ? 'brew install ctags' : 'sudo apt-get install exuberant-ctags';
class BaseInstaller {
    constructor(serviceContainer, outputChannel) {
        this.serviceContainer = serviceContainer;
        this.outputChannel = outputChannel;
        this.appShell = serviceContainer.get(types_2.IApplicationShell);
        this.configService = serviceContainer.get(types_5.IConfigurationService);
        this.productService = serviceContainer.get(types_6.IProductService);
    }
    promptToInstall(product, resource) {
        // If this method gets called twice, while previous promise has not been resolved, then return that same promise.
        // E.g. previous promise is not resolved as a message has been displayed to the user, so no point displaying
        // another message.
        const workspaceFolder = coc_nvim_1.workspace.workspaceFolder;
        const key = `${product}${workspaceFolder ? vscode_uri_1.default.parse(workspaceFolder.uri).fsPath : ''}`;
        if (BaseInstaller.PromptPromises.has(key)) {
            return BaseInstaller.PromptPromises.get(key);
        }
        const promise = this.promptToInstallImplementation(product, resource);
        BaseInstaller.PromptPromises.set(key, promise);
        // tslint:disable-next-line: no-empty
        promise.then(() => BaseInstaller.PromptPromises.delete(key)).catch(() => { });
        promise.catch(() => BaseInstaller.PromptPromises.delete(key));
        return promise;
    }
    async install(product, resource) {
        if (product === types_5.Product.unittest) {
            return types_5.InstallerResponse.Installed;
        }
        const channels = this.serviceContainer.get(types_6.IInstallationChannelManager);
        const installer = await channels.getInstallationChannel(product, resource);
        if (!installer) {
            return types_5.InstallerResponse.Ignore;
        }
        const moduleName = translateProductToModule(product, types_5.ModuleNamePurpose.install);
        const logger = this.serviceContainer.get(types_5.ILogger);
        await installer.installModule(moduleName, resource)
            .catch(logger.logError.bind(logger, `Error in installing the module '${moduleName}'`));
        return this.isInstalled(product, resource)
            .then(isInstalled => isInstalled ? types_5.InstallerResponse.Installed : types_5.InstallerResponse.Ignore);
    }
    async isInstalled(product, resource) {
        if (product === types_5.Product.unittest) {
            return true;
        }
        // User may have customized the module name or provided the fully qualified path.
        const executableName = this.getExecutableNameFromSettings(product, resource);
        const isModule = this.isExecutableAModule(product, resource);
        if (isModule) {
            const pythonProcess = await this.serviceContainer.get(types_4.IPythonExecutionFactory).create({ resource });
            return pythonProcess.isModuleInstalled(executableName);
        }
        else {
            const process = await this.serviceContainer.get(types_4.IProcessServiceFactory).create(resource);
            return process.exec(executableName, ['--version'], { mergeStdOutErr: true })
                .then(() => true)
                .catch(() => false);
        }
    }
    getExecutableNameFromSettings(product, resource) {
        const productType = this.productService.getProductType(product);
        const productPathService = this.serviceContainer.get(types_6.IProductPathService, productType);
        return productPathService.getExecutableNameFromSettings(product, resource);
    }
    isExecutableAModule(product, resource) {
        const productType = this.productService.getProductType(product);
        const productPathService = this.serviceContainer.get(types_6.IProductPathService, productType);
        return productPathService.isExecutableAModule(product, resource);
    }
}
BaseInstaller.PromptPromises = new Map();
exports.BaseInstaller = BaseInstaller;
class CTagsInstaller extends BaseInstaller {
    constructor(serviceContainer, outputChannel) {
        super(serviceContainer, outputChannel);
    }
    async install(_product, _resource) {
        if (this.serviceContainer.get(types_3.IPlatformService).isWindows) {
            this.outputChannel.appendLine('Install Universal Ctags Win32 to enable support for Workspace Symbols');
            this.outputChannel.appendLine('Download the CTags binary from the Universal CTags site.');
            this.outputChannel.appendLine('Option 1: Extract ctags.exe from the downloaded zip to any folder within your PATH so that Visual Studio Code can run it.');
            this.outputChannel.appendLine('Option 2: Extract to any folder and add the path to this folder to the command setting.');
            this.outputChannel.appendLine('Option 3: Extract to any folder and define that path in the python.workspaceSymbols.ctagsPath setting of your user settings file (settings.json).');
            this.outputChannel.show();
        }
        else {
            let res = await coc_nvim_1.workspace.runTerminalCommand(CTagsInsllationScript, process.cwd(), true);
            if (!res.success) {
                const logger = this.serviceContainer.get(types_5.ILogger);
                logger.logError.bind(logger, `Failed to install ctags. Script sent '${CTagsInsllationScript}'.`);
            }
        }
        return types_5.InstallerResponse.Ignore;
    }
    async promptToInstallImplementation(product, resource) {
        const res = await coc_nvim_1.workspace.showPrompt('Install CTags to enable Python workspace symbols?');
        return res ? this.install(product, resource) : types_5.InstallerResponse.Ignore;
    }
}
exports.CTagsInstaller = CTagsInstaller;
class FormatterInstaller extends BaseInstaller {
    async promptToInstallImplementation(product, resource) {
        // Hard-coded on purpose because the UI won't necessarily work having
        // another formatter.
        const formatters = [types_5.Product.autopep8, types_5.Product.black, types_5.Product.yapf];
        const formatterNames = formatters.map(formatter => productNames_1.ProductNames.get(formatter));
        const productName = productNames_1.ProductNames.get(product);
        formatterNames.splice(formatterNames.indexOf(productName), 1);
        const useOptions = formatterNames.map(name => `Use ${name}`);
        const yesChoice = 'Yes';
        const options = [...useOptions];
        let message = `Formatter ${productName} is not installed. Install?`;
        if (this.isExecutableAModule(product, resource)) {
            options.splice(0, 0, yesChoice);
        }
        else {
            const executable = this.getExecutableNameFromSettings(product, resource);
            message = `Path to the ${productName} formatter is invalid (${executable})`;
        }
        const idx = await coc_nvim_1.workspace.showQuickpick(options, message);
        if (idx !== -1) {
            let item = options[idx];
            if (item === yesChoice) {
                return this.install(product, resource);
            }
            else if (typeof item === 'string') {
                for (const formatter of formatters) {
                    const formatterName = productNames_1.ProductNames.get(formatter);
                    if (item.endsWith(formatterName)) {
                        await this.configService.updateSetting('formatting.provider', formatterName, resource);
                        return this.install(formatter, resource);
                    }
                }
            }
        }
        return types_5.InstallerResponse.Ignore;
    }
}
exports.FormatterInstaller = FormatterInstaller;
class LinterInstaller extends BaseInstaller {
    async promptToInstallImplementation(product, resource) {
        const isPylint = product === types_5.Product.pylint;
        const productName = productNames_1.ProductNames.get(product);
        const install = 'Install';
        const disableInstallPrompt = 'Do not show again';
        const disableLinterInstallPromptKey = `${productName}_DisableLinterInstallPrompt`;
        const selectLinter = 'Select Linter';
        if (isPylint && this.getStoredResponse(disableLinterInstallPromptKey) === true) {
            return types_5.InstallerResponse.Ignore;
        }
        const options = isPylint ? [selectLinter, disableInstallPrompt] : [selectLinter];
        let message = `Linter ${productName} is not installed.`;
        if (this.isExecutableAModule(product, resource)) {
            options.splice(0, 0, install);
        }
        else {
            const executable = this.getExecutableNameFromSettings(product, resource);
            message = `Path to the ${productName} linter is invalid (${executable})`;
        }
        const idx = await coc_nvim_1.workspace.showQuickpick(options, message);
        if (idx !== -1) {
            let response = options[idx];
            if (response === install) {
                return this.install(product, resource);
            }
            else if (response === disableInstallPrompt) {
                await this.setStoredResponse(disableLinterInstallPromptKey, true);
                return types_5.InstallerResponse.Ignore;
            }
            if (response === selectLinter) {
                const commandManager = this.serviceContainer.get(types_2.ICommandManager);
                commandManager.executeCommand(constants_1.Commands.Set_Linter);
            }
        }
        return types_5.InstallerResponse.Ignore;
    }
    /**
     * For installers that want to avoid prompting the user over and over, they can make use of a
     * persisted true/false value representing user responses to 'stop showing this prompt'. This method
     * gets the persisted value given the installer-defined key.
     *
     * @param key Key to use to get a persisted response value, each installer must define this for themselves.
     * @returns Boolean: The current state of the stored response key given.
     */
    getStoredResponse(key) {
        const factory = this.serviceContainer.get(types_5.IPersistentStateFactory);
        const state = factory.createGlobalPersistentState(key, undefined);
        return state.value === true;
    }
    /**
     * For installers that want to avoid prompting the user over and over, they can make use of a
     * persisted true/false value representing user responses to 'stop showing this prompt'. This
     * method will set that persisted value given the installer-defined key.
     *
     * @param key Key to use to get a persisted response value, each installer must define this for themselves.
     * @param value Boolean value to store for the user - if they choose to not be prompted again for instance.
     * @returns Boolean: The current state of the stored response key given.
     */
    async setStoredResponse(key, value) {
        const factory = this.serviceContainer.get(types_5.IPersistentStateFactory);
        const state = factory.createGlobalPersistentState(key, undefined);
        if (state && state.value !== value) {
            await state.updateValue(value);
        }
    }
}
exports.LinterInstaller = LinterInstaller;
class TestFrameworkInstaller extends BaseInstaller {
    async promptToInstallImplementation(product, resource) {
        const productName = productNames_1.ProductNames.get(product);
        const options = [];
        let message = `Test framework ${productName} is not installed. Install?`;
        if (this.isExecutableAModule(product, resource)) {
            options.push(...['Yes', 'No']);
        }
        else {
            const executable = this.getExecutableNameFromSettings(product, resource);
            message = `Path to the ${productName} test framework is invalid (${executable})`;
        }
        const idx = await coc_nvim_1.workspace.showQuickpick(options, message);
        return idx !== -1 && options[idx] == 'Yes' ? this.install(product, resource) : types_5.InstallerResponse.Ignore;
    }
}
exports.TestFrameworkInstaller = TestFrameworkInstaller;
class RefactoringLibraryInstaller extends BaseInstaller {
    async promptToInstallImplementation(product, resource) {
        const productName = productNames_1.ProductNames.get(product);
        const res = await coc_nvim_1.workspace.showPrompt(`Refactoring library ${productName} is not installed. Install?`);
        return res ? this.install(product, resource) : types_5.InstallerResponse.Ignore;
    }
}
exports.RefactoringLibraryInstaller = RefactoringLibraryInstaller;
let ProductInstaller = class ProductInstaller {
    constructor(serviceContainer, outputChannel) {
        this.serviceContainer = serviceContainer;
        this.outputChannel = outputChannel;
        this.productService = serviceContainer.get(types_6.IProductService);
    }
    // tslint:disable-next-line:no-empty
    dispose() { }
    async promptToInstall(product, resource) {
        return this.createInstaller(product).promptToInstall(product, resource);
    }
    async install(product, resource) {
        return this.createInstaller(product).install(product, resource);
    }
    async isInstalled(product, resource) {
        return this.createInstaller(product).isInstalled(product, resource);
    }
    translateProductToModuleName(product, purpose) {
        return translateProductToModule(product, purpose);
    }
    createInstaller(product) {
        const productType = this.productService.getProductType(product);
        switch (productType) {
            case types_5.ProductType.Formatter:
                return new FormatterInstaller(this.serviceContainer, this.outputChannel);
            case types_5.ProductType.Linter:
                return new LinterInstaller(this.serviceContainer, this.outputChannel);
            case types_5.ProductType.WorkspaceSymbols:
                return new CTagsInstaller(this.serviceContainer, this.outputChannel);
            case types_5.ProductType.TestFramework:
                return new TestFrameworkInstaller(this.serviceContainer, this.outputChannel);
            case types_5.ProductType.RefactoringLibrary:
                return new RefactoringLibraryInstaller(this.serviceContainer, this.outputChannel);
            default:
                break;
        }
        throw new Error(`Unknown product ${product}`);
    }
};
ProductInstaller = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_1.IServiceContainer)),
    __param(1, inversify_1.inject(types_5.IOutputChannel)), __param(1, inversify_1.named(constants_1.STANDARD_OUTPUT_CHANNEL))
], ProductInstaller);
exports.ProductInstaller = ProductInstaller;
function translateProductToModule(product, purpose) {
    switch (product) {
        case types_5.Product.mypy: return 'mypy';
        case types_5.Product.nosetest: {
            return purpose === types_5.ModuleNamePurpose.install ? 'nose' : 'nosetests';
        }
        case types_5.Product.pylama: return 'pylama';
        case types_5.Product.prospector: return 'prospector';
        case types_5.Product.pylint: return 'pylint';
        case types_5.Product.pytest: return 'pytest';
        case types_5.Product.autopep8: return 'autopep8';
        case types_5.Product.black: return 'black';
        case types_5.Product.pep8: return 'pep8';
        case types_5.Product.pydocstyle: return 'pydocstyle';
        case types_5.Product.yapf: return 'yapf';
        case types_5.Product.flake8: return 'flake8';
        case types_5.Product.unittest: return 'unittest';
        case types_5.Product.rope: return 'rope';
        case types_5.Product.bandit: return 'bandit';
        default: {
            throw new Error(`Product ${product} cannot be installed as a Python Module.`);
        }
    }
}
//# sourceMappingURL=productInstaller.js.map