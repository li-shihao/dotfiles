"use strict";
// tslint:disable:no-console no-any
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Logger_1;
const inversify_1 = require("inversify");
const helpers_1 = require("./helpers");
const types_1 = require("./types");
const PREFIX = 'Python Extension: ';
let Logger = Logger_1 = class Logger {
    // tslint:disable-next-line:no-any
    static error(title = '', message) {
        new Logger_1().logError(`${title}, ${message}`);
    }
    // tslint:disable-next-line:no-any
    static warn(title = '', message = '') {
        new Logger_1().logWarning(`${title}, ${message}`);
    }
    // tslint:disable-next-line:no-any
    static verbose(title = '') {
        new Logger_1().logInformation(title);
    }
    logError(message, ex) {
        if (ex) {
            console.error(`${PREFIX}${message}`, ex);
        }
        else {
            console.error(`${PREFIX}${message}`);
        }
    }
    logWarning(message, ex) {
        if (ex) {
            console.warn(`${PREFIX}${message}`, ex);
        }
        else {
            console.warn(`${PREFIX}${message}`);
        }
    }
    logInformation(message, ex) {
        if (ex) {
            console.info(`${PREFIX}${message}`, ex);
        }
        else {
            console.info(`${PREFIX}${message}`);
        }
    }
};
__decorate([
    helpers_1.skipIfTest(false)
], Logger.prototype, "logError", null);
__decorate([
    helpers_1.skipIfTest(false)
], Logger.prototype, "logWarning", null);
__decorate([
    helpers_1.skipIfTest(false)
], Logger.prototype, "logInformation", null);
Logger = Logger_1 = __decorate([
    inversify_1.injectable()
], Logger);
exports.Logger = Logger;
var LogOptions;
(function (LogOptions) {
    LogOptions[LogOptions["None"] = 0] = "None";
    LogOptions[LogOptions["Arguments"] = 1] = "Arguments";
    LogOptions[LogOptions["ReturnValue"] = 2] = "ReturnValue";
})(LogOptions = exports.LogOptions || (exports.LogOptions = {}));
// tslint:disable-next-line:no-any
function argsToLogString(args) {
    try {
        return (args || [])
            .map((item, index) => {
            if (item === undefined) {
                return `Arg ${index + 1}: undefined`;
            }
            if (item === null) {
                return `Arg ${index + 1}: null`;
            }
            try {
                if (item && item.fsPath) {
                    return `Arg ${index + 1}: <Uri:${item.fsPath}>`;
                }
                return `Arg ${index + 1}: ${JSON.stringify(item)}`;
            }
            catch (_a) {
                return `Arg ${index + 1}: <argument cannot be serialized for logging>`;
            }
        })
            .join(', ');
    }
    catch (_a) {
        return '';
    }
}
// tslint:disable-next-line:no-any
function returnValueToLogString(returnValue) {
    const returnValueMessage = 'Return Value: ';
    if (returnValue === undefined) {
        return `${returnValueMessage}undefined`;
    }
    if (returnValue === null) {
        return `${returnValueMessage}null`;
    }
    try {
        return `${returnValueMessage}${JSON.stringify(returnValue)}`;
    }
    catch (_a) {
        return `${returnValueMessage}<Return value cannot be serialized for logging>`;
    }
}
function traceVerbose(message) {
    new Logger().logInformation(message);
}
exports.traceVerbose = traceVerbose;
function traceError(message, ex) {
    new Logger().logError(message, ex);
}
exports.traceError = traceError;
function traceInfo(message) {
    new Logger().logInformation(message);
}
exports.traceInfo = traceInfo;
var traceDecorators;
(function (traceDecorators) {
    function verbose(message, options = LogOptions.Arguments | LogOptions.ReturnValue) {
        return trace(message, options);
    }
    traceDecorators.verbose = verbose;
    function error(message) {
        return trace(message, LogOptions.Arguments | LogOptions.ReturnValue, types_1.LogLevel.Error);
    }
    traceDecorators.error = error;
    function info(message) {
        return trace(message);
    }
    traceDecorators.info = info;
    function warn(message) {
        return trace(message, LogOptions.Arguments | LogOptions.ReturnValue, types_1.LogLevel.Warning);
    }
    traceDecorators.warn = warn;
})(traceDecorators = exports.traceDecorators || (exports.traceDecorators = {}));
function trace(message, options = LogOptions.None, logLevel) {
    // tslint:disable-next-line:no-function-expression no-any
    return function (_, __, descriptor) {
        const originalMethod = descriptor.value;
        // tslint:disable-next-line:no-function-expression no-any
        descriptor.value = function (...args) {
            const className = _ && _.constructor ? _.constructor.name : '';
            // tslint:disable-next-line:no-any
            function writeSuccess(returnValue) {
                if (logLevel === types_1.LogLevel.Error) {
                    return;
                }
                writeToLog(returnValue);
            }
            function writeError(ex) {
                writeToLog(undefined, ex);
            }
            // tslint:disable-next-line:no-any
            function writeToLog(returnValue, ex) {
                const messagesToLog = [message];
                messagesToLog.push(`Class name = ${className}`);
                if ((options && LogOptions.Arguments) === LogOptions.Arguments) {
                    messagesToLog.push(argsToLogString(args));
                }
                if ((options & LogOptions.ReturnValue) === LogOptions.ReturnValue) {
                    messagesToLog.push(returnValueToLogString(returnValue));
                }
                if (ex) {
                    new Logger().logError(messagesToLog.join(', '), ex);
                }
                else {
                    new Logger().logInformation(messagesToLog.join(', '));
                }
            }
            try {
                // tslint:disable-next-line:no-invalid-this no-use-before-declare no-unsafe-any
                const result = originalMethod.apply(this, args);
                // If method being wrapped returns a promise then wait for it.
                // tslint:disable-next-line:no-unsafe-any
                if (result && typeof result.then === 'function' && typeof result.catch === 'function') {
                    // tslint:disable-next-line:prefer-type-cast
                    result
                        .then(data => {
                        writeSuccess(data);
                        return data;
                    })
                        .catch(ex => {
                        writeError(ex);
                    });
                }
                else {
                    writeSuccess(result);
                }
                return result;
            }
            catch (ex) {
                writeError(ex);
                throw ex;
            }
        };
        return descriptor;
    };
}
//# sourceMappingURL=logger.js.map