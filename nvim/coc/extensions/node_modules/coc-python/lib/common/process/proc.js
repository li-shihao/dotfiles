"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const child_process_1 = require("child_process");
const Observable_1 = require("rxjs/Observable");
const tree_kill_1 = __importDefault(require("tree-kill"));
const async_1 = require("../utils/async");
const constants_1 = require("./constants");
const types_1 = require("./types");
// tslint:disable:no-any
class ProcessService {
    constructor(decoder, env) {
        this.decoder = decoder;
        this.env = env;
    }
    static isAlive(pid) {
        try {
            process.kill(pid, 0);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    static kill(pid) {
        // tslint:disable-next-line:no-require-imports
        const killProcessTree = require('tree-kill');
        try {
            killProcessTree(pid);
        }
        catch (_a) {
            // Ignore.
        }
    }
    execObservable(file, args, options = {}) {
        const spawnOptions = this.getDefaultOptions(options);
        const encoding = spawnOptions.encoding ? spawnOptions.encoding : 'utf8';
        const proc = child_process_1.spawn(file, args, spawnOptions);
        let procExited = false;
        const output = new Observable_1.Observable(subscriber => {
            if (options.token) {
                options.token.onCancellationRequested(() => {
                    if (!procExited && !proc.killed) {
                        proc.kill();
                        procExited = true;
                    }
                });
            }
            const sendOutput = (source, data) => {
                const out = this.decoder.decode([data], encoding);
                if (source === 'stderr' && options.throwOnStdErr) {
                    subscriber.error(new types_1.StdErrError(out));
                }
                else {
                    subscriber.next({ source, out });
                }
            };
            proc.stdout.on('data', (data) => sendOutput('stdout', data));
            proc.stderr.on('data', (data) => sendOutput('stderr', data));
            const onExit = (ex) => {
                if (procExited)
                    return;
                procExited = true;
                if (ex)
                    subscriber.error(ex);
                subscriber.complete();
            };
            proc.once('close', () => {
                onExit();
            });
            proc.once('error', onExit);
        });
        return {
            proc,
            out: output,
            dispose: () => {
                if (proc && !proc.killed) {
                    tree_kill_1.default(proc.pid);
                }
            }
        };
    }
    exec(file, args, options = {}) {
        const spawnOptions = this.getDefaultOptions(options);
        const encoding = spawnOptions.encoding ? spawnOptions.encoding : 'utf8';
        const proc = child_process_1.spawn(file, args, spawnOptions);
        const deferred = async_1.createDeferred();
        if (options.token) {
            options.token.onCancellationRequested(() => {
                if (!proc.killed && !deferred.completed) {
                    proc.kill();
                }
            });
        }
        const stdoutBuffers = [];
        proc.stdout.on('data', (data) => stdoutBuffers.push(data));
        const stderrBuffers = [];
        proc.stderr.on('data', (data) => {
            if (options.mergeStdOutErr) {
                stdoutBuffers.push(data);
                stderrBuffers.push(data);
            }
            else {
                stderrBuffers.push(data);
            }
        });
        proc.once('close', () => {
            if (deferred.completed) {
                return;
            }
            const stderr = stderrBuffers.length === 0 ? undefined : this.decoder.decode(stderrBuffers, encoding);
            if (stderr && stderr.length > 0 && options.throwOnStdErr) {
                deferred.reject(new types_1.StdErrError(stderr));
            }
            else {
                const stdout = this.decoder.decode(stdoutBuffers, encoding);
                deferred.resolve({ stdout, stderr });
            }
        });
        proc.once('error', ex => {
            deferred.reject(ex);
        });
        return deferred.promise;
    }
    shellExec(command, options = {}) {
        const shellOptions = this.getDefaultOptions(options);
        return new Promise((resolve, reject) => {
            child_process_1.exec(command, shellOptions, (e, stdout, stderr) => {
                if (e && e !== null) {
                    reject(e);
                }
                else if (shellOptions.throwOnStdErr && stderr && stderr.length) {
                    reject(new Error(stderr));
                }
                else {
                    // Make sure stderr is undefined if we actually had none. This is checked
                    // elsewhere because that's how exec behaves.
                    resolve({ stderr: stderr && stderr.length > 0 ? stderr : undefined, stdout });
                }
            });
        });
    }
    getDefaultOptions(options) {
        const defaultOptions = Object.assign({}, options);
        const execOptions = defaultOptions;
        if (execOptions) {
            const encoding = execOptions.encoding = typeof execOptions.encoding === 'string' && execOptions.encoding.length > 0 ? execOptions.encoding : constants_1.DEFAULT_ENCODING;
            delete execOptions.encoding;
            execOptions.encoding = encoding;
        }
        if (!defaultOptions.env || Object.keys(defaultOptions.env).length === 0) {
            const env = this.env ? this.env : process.env;
            defaultOptions.env = Object.assign({}, env);
        }
        else {
            defaultOptions.env = Object.assign({}, defaultOptions.env);
        }
        // Always ensure we have unbuffered output.
        defaultOptions.env.PYTHONUNBUFFERED = '1';
        if (!defaultOptions.env.PYTHONIOENCODING) {
            defaultOptions.env.PYTHONIOENCODING = 'utf-8';
        }
        return defaultOptions;
    }
}
exports.ProcessService = ProcessService;
//# sourceMappingURL=proc.js.map