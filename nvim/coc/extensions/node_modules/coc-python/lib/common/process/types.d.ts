/// <reference types="node" />
import { ChildProcess, ExecOptions, SpawnOptions as ChildProcessSpawnOptions } from 'child_process';
import { Observable } from 'rxjs/Observable';
import Uri from 'vscode-uri';
import { CancellationToken } from 'vscode-languageserver-protocol';
import { PythonInterpreter } from '../../interpreter/contracts';
import { ExecutionInfo, Version } from '../types';
import { Architecture } from '../utils/platform';
import { EnvironmentVariables } from '../variables/types';
export declare const IBufferDecoder: unique symbol;
export interface IBufferDecoder {
    decode(buffers: Buffer[], encoding: string): string;
}
export interface Output<T extends string | Buffer> {
    source: 'stdout' | 'stderr';
    out: T;
}
export interface ObservableExecutionResult<T extends string | Buffer> {
    proc: ChildProcess | undefined;
    out: Observable<Output<T>>;
    dispose(): void;
}
export declare type SpawnOptions = ChildProcessSpawnOptions & {
    encoding?: string;
    token?: CancellationToken;
    mergeStdOutErr?: boolean;
    throwOnStdErr?: boolean;
};
export declare type ShellOptions = ExecOptions & {
    throwOnStdErr?: boolean;
};
export interface ExecutionResult<T extends string | Buffer> {
    stdout: T;
    stderr?: T;
}
export interface IProcessService {
    execObservable(file: string, args: string[], options?: SpawnOptions): ObservableExecutionResult<string>;
    exec(file: string, args: string[], options?: SpawnOptions): Promise<ExecutionResult<string>>;
    shellExec(command: string, options?: ShellOptions): Promise<ExecutionResult<string>>;
}
export declare const IProcessServiceFactory: unique symbol;
export interface IProcessServiceFactory {
    create(resource?: Uri): Promise<IProcessService>;
}
export declare const IPythonExecutionFactory: unique symbol;
export interface ExecutionFactoryCreationOptions {
    resource?: Uri;
    pythonPath?: string;
}
export interface ExecutionFactoryCreateWithEnvironmentOptions {
    resource?: Uri;
    interpreter?: PythonInterpreter;
    allowEnvironmentFetchExceptions?: boolean;
}
export interface IPythonExecutionFactory {
    create(options: ExecutionFactoryCreationOptions): Promise<IPythonExecutionService>;
    createActivatedEnvironment(options: ExecutionFactoryCreateWithEnvironmentOptions): Promise<IPythonExecutionService>;
}
export declare type ReleaseLevel = 'alpha' | 'beta' | 'candidate' | 'final' | 'unknown';
export declare type PythonVersionInfo = [number, number, number, ReleaseLevel];
export interface InterpreterInfomation {
    path: string;
    version?: Version;
    sysVersion: string;
    architecture: Architecture;
    sysPrefix: string;
    pipEnvWorkspaceFolder?: string;
}
export declare const IPythonExecutionService: unique symbol;
export interface IPythonExecutionService {
    getInterpreterInformation(): Promise<InterpreterInfomation | undefined>;
    getExecutablePath(): Promise<string>;
    isModuleInstalled(moduleName: string): Promise<boolean>;
    execObservable(args: string[], options: SpawnOptions): ObservableExecutionResult<string>;
    execModuleObservable(moduleName: string, args: string[], options: SpawnOptions): ObservableExecutionResult<string>;
    exec(args: string[], options: SpawnOptions): Promise<ExecutionResult<string>>;
    execModule(moduleName: string, args: string[], options: SpawnOptions): Promise<ExecutionResult<string>>;
}
export declare class StdErrError extends Error {
    constructor(message: string);
}
export interface IExecutionEnvironmentVariablesService {
    getEnvironmentVariables(resource?: Uri): Promise<EnvironmentVariables | undefined>;
}
export declare const IPythonToolExecutionService: unique symbol;
export interface IPythonToolExecutionService {
    execObservable(executionInfo: ExecutionInfo, options: SpawnOptions, resource: Uri): Promise<ObservableExecutionResult<string>>;
    exec(executionInfo: ExecutionInfo, options: SpawnOptions, resource: Uri): Promise<ExecutionResult<string>>;
}
