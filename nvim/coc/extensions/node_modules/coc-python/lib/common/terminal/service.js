"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const inversify_1 = require("inversify");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const types_1 = require("../../ioc/types");
const types_2 = require("../application/types");
const types_3 = require("../types");
const types_4 = require("./types");
let TerminalService = class TerminalService {
    constructor(serviceContainer, resource, title = 'Python') {
        this.serviceContainer = serviceContainer;
        this.resource = resource;
        this.title = title;
        this.terminalClosed = new vscode_languageserver_protocol_1.Emitter();
        const disposableRegistry = this.serviceContainer.get(types_3.IDisposableRegistry);
        disposableRegistry.push(this);
        this.terminalHelper = this.serviceContainer.get(types_4.ITerminalHelper);
        this.terminalManager = this.serviceContainer.get(types_2.ITerminalManager);
        this.terminalManager.onDidCloseTerminal(this.terminalCloseHandler, this, disposableRegistry);
        this.terminalActivator = this.serviceContainer.get(types_4.ITerminalActivator);
    }
    get onDidCloseTerminal() {
        return this.terminalClosed.event.bind(this.terminalClosed);
    }
    dispose() {
        if (this.terminal) {
            this.terminal.dispose();
        }
    }
    async sendCommand(command, args) {
        await this.ensureTerminal();
        const text = this.terminalHelper.buildCommandForTerminal(this.terminalShellType, command, args);
        this.terminal.show(true);
        this.terminal.sendText(text, true);
    }
    async sendText(text) {
        await this.ensureTerminal();
        this.terminal.show(true);
        this.terminal.sendText(text);
    }
    async show(preserveFocus = true) {
        await this.ensureTerminal(preserveFocus);
        this.terminal.show(preserveFocus);
    }
    async ensureTerminal(preserveFocus = true) {
        if (this.terminal) {
            return;
        }
        const shellPath = this.terminalHelper.getTerminalShellPath();
        this.terminalShellType = !shellPath || shellPath.length === 0 ? types_4.TerminalShellType.other : this.terminalHelper.identifyTerminalShell(shellPath);
        this.terminal = await this.terminalManager.createTerminal({ name: this.title, shellPath, shellArgs: [] });
        await this.terminalActivator.activateEnvironmentInTerminal(this.terminal, this.resource, preserveFocus);
        this.terminal.show(preserveFocus);
        // this.sendTelemetry().catch(emptyFn)
    }
    terminalCloseHandler(terminal) {
        if (terminal === this.terminal) {
            this.terminalClosed.fire();
            this.terminal = undefined;
        }
    }
};
TerminalService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_1.IServiceContainer))
], TerminalService);
exports.TerminalService = TerminalService;
//# sourceMappingURL=service.js.map