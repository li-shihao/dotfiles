"use strict";
// tslint:disable:no-any no-require-imports no-function-expression no-invalid-this
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const logger_1 = require("../logger");
const cacheUtils_1 = require("./cacheUtils");
const coc_nvim_1 = require("coc.nvim");
const function_1 = require("../function");
// tslint:disable-next-line:no-require-imports no-var-requires
const _debounce = require('lodash/debounce');
/**
 * Debounces a function execution. Function must return either a void or a promise that resolves to a void.
 * @export
 * @param {number} [wait] Wait time.
 * @returns void
 */
function debounce(wait) {
    // tslint:disable-next-line:no-any no-function-expression
    return function (_target, _propertyName, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = _debounce(function () { return originalMethod.apply(this, arguments); }, wait);
    };
}
exports.debounce = debounce;
function clearCachedResourceSpecificIngterpreterData(key, resource) {
    const cache = new cacheUtils_1.InMemoryInterpreterSpecificCache(key, 0, [resource]);
    cache.clear();
}
exports.clearCachedResourceSpecificIngterpreterData = clearCachedResourceSpecificIngterpreterData;
function cacheResourceSpecificInterpreterData(key, expiryDurationMs) {
    return function (_target, _propertyName, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = async function (...args) {
            const cache = new cacheUtils_1.InMemoryInterpreterSpecificCache(key, expiryDurationMs, args);
            if (cache.hasData) {
                logger_1.traceVerbose(`Cached data exists ${key}, ${args[0] ? args[0].fsPath : '<No Resource>'}`);
                return Promise.resolve(cache.data);
            }
            const promise = originalMethod.apply(this, args);
            promise.then(result => cache.data = result).catch(function_1.emptyFn);
            return promise;
        };
    };
}
exports.cacheResourceSpecificInterpreterData = cacheResourceSpecificInterpreterData;
/**
 * Swallows exceptions thrown by a function. Function must return either a void or a promise that resolves to a void.
 * When exceptions (including in promises) are caught, this will return `undefined` to calling code.
 * @export
 * @param {string} [scopeName] Scope for the error message to be logged along with the error.
 * @returns void
 */
function swallowExceptions(scopeName) {
    // tslint:disable-next-line:no-any no-function-expression
    return function (_target, propertyName, descriptor) {
        const originalMethod = descriptor.value;
        const errorMessage = `Python Extension (Error in ${scopeName}, method:${propertyName}):`;
        // tslint:disable-next-line:no-any no-function-expression
        descriptor.value = function (...args) {
            try {
                // tslint:disable-next-line:no-invalid-this no-use-before-declare no-unsafe-any
                const result = originalMethod.apply(this, args);
                // If method being wrapped returns a promise then wait and swallow errors.
                if (result && typeof result.then === 'function' && typeof result.catch === 'function') {
                    return result.catch(error => {
                        if (constants_1.isTestExecution()) {
                            return;
                        }
                        logger_1.traceError(errorMessage, error);
                    });
                }
            }
            catch (error) {
                if (constants_1.isTestExecution()) {
                    return;
                }
                logger_1.traceError(errorMessage, error);
            }
        };
    };
}
exports.swallowExceptions = swallowExceptions;
function displayProgress(title) {
    let item = coc_nvim_1.workspace.createStatusBarItem(0, { progress: true });
    item.text = title;
    return function (_target, _propertyName, descriptor) {
        const originalMethod = descriptor.value;
        // tslint:disable-next-line:no-any no-function-expression
        descriptor.value = async function (...args) {
            item.show();
            // tslint:disable-next-line:no-invalid-this
            const promise = originalMethod.apply(this, args);
            Promise.resolve(promise).then(() => {
                item.hide();
            }, () => {
                item.hide();
            });
            return promise;
        };
    };
}
exports.displayProgress = displayProgress;
//# sourceMappingURL=decorators.js.map