// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const tmp_1 = __importDefault(require("tmp"));
function fsExistsAsync(filePath) {
    return new Promise(resolve => {
        fs_1.default.exists(filePath, exists => {
            return resolve(exists);
        });
    });
}
exports.fsExistsAsync = fsExistsAsync;
function fsReaddirAsync(root) {
    return new Promise(resolve => {
        // Now look for Interpreters in this directory
        fs_1.default.readdir(root, (err, subDirs) => {
            if (err) {
                return resolve([]);
            }
            resolve(subDirs.map(subDir => path_1.default.join(root, subDir)));
        });
    });
}
exports.fsReaddirAsync = fsReaddirAsync;
function getSubDirectories(rootDir) {
    return new Promise(resolve => {
        fs_1.default.readdir(rootDir, (error, files) => {
            if (error) {
                return resolve([]);
            }
            const subDirs = [];
            files.forEach(name => {
                const fullPath = path_1.default.join(rootDir, name);
                try {
                    if (fs_1.default.statSync(fullPath).isDirectory()) {
                        subDirs.push(fullPath);
                    }
                }
                // tslint:disable-next-line:no-empty one-line
                catch (ex) { }
            });
            resolve(subDirs);
        });
    });
}
exports.getSubDirectories = getSubDirectories;
function createTemporaryFile(extension, temporaryDirectory) {
    // tslint:disable-next-line:no-any
    const options = { postfix: extension };
    if (temporaryDirectory) {
        options.dir = temporaryDirectory;
    }
    return new Promise((resolve, reject) => {
        tmp_1.default.file(options, (err, tmpFile, _fd, cleanupCallback) => {
            if (err) {
                return reject(err);
            }
            resolve({ filePath: tmpFile, cleanupCallback });
        });
    });
}
exports.createTemporaryFile = createTemporaryFile;
//# sourceMappingURL=fs.js.map