"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const types_1 = require("../common/application/types");
const constants_1 = require("../common/constants");
const helpers_1 = require("../common/helpers");
const types_2 = require("../common/process/types");
const types_3 = require("../common/types");
const editor_1 = require("./../common/editor");
const types_4 = require("./types");
const coc_nvim_1 = require("coc.nvim");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const function_1 = require("../common/function");
class BaseFormatter {
    constructor(Id, product, serviceContainer) {
        this.Id = Id;
        this.product = product;
        this.serviceContainer = serviceContainer;
        this.outputChannel = serviceContainer.get(types_3.IOutputChannel, constants_1.STANDARD_OUTPUT_CHANNEL);
        this.helper = serviceContainer.get(types_4.IFormatterHelper);
        this.workspace = serviceContainer.get(types_1.IWorkspaceService);
    }
    getDocumentPath(document, fallbackPath) {
        let filepath = vscode_uri_1.default.parse(document.uri).fsPath;
        if (path_1.default.basename(filepath) === filepath) {
            return fallbackPath;
        }
        return path_1.default.dirname(filepath);
    }
    getWorkspaceUri(document) {
        let { rootPath } = coc_nvim_1.workspace;
        let filepath = vscode_uri_1.default.parse(document.uri).fsPath;
        if (!filepath.startsWith(rootPath))
            return null;
        return vscode_uri_1.default.file(rootPath);
    }
    async provideDocumentFormattingEdits(document, _options, token, args, cwd) {
        if (typeof cwd !== 'string' || cwd.length === 0) {
            cwd = this.getWorkspaceUri(document).fsPath;
        }
        // autopep8 and yapf have the ability to read from the process input stream and return the formatted code out of the output stream.
        // However they don't support returning the diff of the formatted text when reading data from the input stream.
        // Yet getting text formatted that way avoids having to create a temporary file, however the diffing will have
        // to be done here in node (extension), i.e. extension CPU, i.e. less responsive solution.
        let filepath = vscode_uri_1.default.parse(document.uri).fsPath;
        const tempFile = await this.createTempFile(document);
        if (this.checkCancellation(filepath, tempFile, token)) {
            return [];
        }
        const executionInfo = this.helper.getExecutionInfo(this.product, args, vscode_uri_1.default.parse(document.uri));
        executionInfo.args.push(tempFile);
        const pythonToolsExecutionService = this.serviceContainer.get(types_2.IPythonToolExecutionService);
        const promise = pythonToolsExecutionService.exec(executionInfo, { cwd, throwOnStdErr: false, token }, vscode_uri_1.default.parse(document.uri))
            .then(output => output.stdout)
            .then(data => {
            if (this.checkCancellation(filepath, tempFile, token)) {
                return [];
            }
            return editor_1.getTextEditsFromPatch(document.getText(), data);
        })
            .catch(error => {
            if (this.checkCancellation(filepath, tempFile, token)) {
                return [];
            }
            // tslint:disable-next-line:no-empty
            this.handleError(this.Id, error, vscode_uri_1.default.parse(document.uri)).catch(() => { });
            return [];
        })
            .then(edits => {
            this.deleteTempFile(filepath, tempFile).catch(function_1.emptyFn);
            return edits;
        });
        // tslint:disable-next-line: no-floating-promises
        promise.then(() => {
            coc_nvim_1.workspace.showMessage(`Formatted with ${this.Id}`);
            let { nvim } = coc_nvim_1.workspace;
            setTimeout(async () => {
                let line = await nvim.call('coc#util#echo_line');
                if (line && /Formatted/.test(line))
                    nvim.command('echo ""', true);
            }, 2000);
        });
        return promise;
    }
    async handleError(_expectedFileName, error, resource) {
        let customError = `Formatting with ${this.Id} failed.`;
        if (helpers_1.isNotInstalledError(error)) {
            const installer = this.serviceContainer.get(types_3.IInstaller);
            const isInstalled = await installer.isInstalled(this.product, resource);
            if (!isInstalled) {
                customError += `\nYou could either install the '${this.Id}' formatter, turn it off or use another formatter.`;
                installer.promptToInstall(this.product, resource).catch(ex => console.error('Python Extension: promptToInstall', ex));
            }
        }
        this.outputChannel.appendLine(`\n${customError}\n${error}`);
    }
    createTempFile(document) {
        return editor_1.getTempFileWithDocumentContents(document);
    }
    deleteTempFile(originalFile, tempFile) {
        if (originalFile !== tempFile) {
            return fs_extra_1.default.unlink(tempFile);
        }
        return Promise.resolve();
    }
    checkCancellation(originalFile, tempFile, token) {
        if (token && token.isCancellationRequested) {
            this.deleteTempFile(originalFile, tempFile).catch(function_1.emptyFn);
            return true;
        }
        return false;
    }
}
exports.BaseFormatter = BaseFormatter;
//# sourceMappingURL=baseFormatter.js.map