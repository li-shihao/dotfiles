'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-var-requires no-require-imports
// This line should always be right on top.
// tslint:disable:no-any
require('reflect-metadata');
// Initialize source maps (this must never be moved up nor further down).
const coc_nvim_1 = require("coc.nvim");
const inversify_1 = require("inversify");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const serviceRegistry_1 = require("./activation/serviceRegistry");
const types_1 = require("./activation/types");
const api_1 = require("./api");
const serviceRegistry_2 = require("./application/serviceRegistry");
const types_2 = require("./application/types");
const types_3 = require("./common/application/types");
const constants_1 = require("./common/constants");
const serviceRegistry_3 = require("./common/dotnet/serviceRegistry");
const serviceRegistry_4 = require("./common/installer/serviceRegistry");
const serviceRegistry_5 = require("./common/platform/serviceRegistry");
const serviceRegistry_6 = require("./common/process/serviceRegistry");
const serviceRegistry_7 = require("./common/serviceRegistry");
// import { ITerminalHelper } from './common/terminal/types'
const types_4 = require("./common/types");
const async_1 = require("./common/utils/async");
const stopWatch_1 = require("./common/utils/stopWatch");
// import { Common } from './common/utils/localize'
const serviceRegistry_8 = require("./common/variables/serviceRegistry");
const serviceRegistry_9 = require("./formatters/serviceRegistry");
const types_5 = require("./interpreter/configuration/types");
const contracts_1 = require("./interpreter/contracts");
const serviceRegistry_10 = require("./interpreter/serviceRegistry");
const container_1 = require("./ioc/container");
const serviceManager_1 = require("./ioc/serviceManager");
const types_6 = require("./ioc/types");
const linterCommands_1 = require("./linters/linterCommands");
const serviceRegistry_11 = require("./linters/serviceRegistry");
// import { ILintingEngine } from './linters/types'
const codeActionsProvider_1 = require("./providers/codeActionsProvider");
const formatProvider_1 = require("./providers/formatProvider");
const linterProvider_1 = require("./providers/linterProvider");
const replProvider_1 = require("./providers/replProvider");
const serviceRegistry_12 = require("./providers/serviceRegistry");
const simpleRefactorProvider_1 = require("./providers/simpleRefactorProvider");
const terminalProvider_1 = require("./providers/terminalProvider");
const types_7 = require("./providers/types");
const updateSparkLibraryProvider_1 = require("./providers/updateSparkLibraryProvider");
const sourceMapSupport_1 = require("./sourceMapSupport");
const serviceRegistry_13 = require("./terminals/serviceRegistry");
const types_8 = require("./terminals/types");
sourceMapSupport_1.initialize();
const durations = {};
// Do not move this line of code (used to measure extension load times).
const stopWatch = new stopWatch_1.StopWatch();
// import { TEST_OUTPUT_CHANNEL } from './unittests/common/constants'
// import { ITestContextService } from './unittests/common/types'
// import { ITestCodeNavigatorCommandHandler, ITestExplorerCommandHandler } from './unittests/navigation/types'
// import { registerTypes as unitTestsRegisterTypes } from './unittests/serviceRegistry'
durations.codeLoadingTime = stopWatch.elapsedTime;
const activationDeferred = async_1.createDeferred();
let activatedServiceContainer;
async function activate(context) {
    let statusItem = coc_nvim_1.workspace.createStatusBarItem(0, { progress: true });
    statusItem.text = 'loading python extension.';
    statusItem.show();
    try {
        let res = await activateUnsafe(context);
        statusItem.dispose();
        return res;
    }
    catch (ex) {
        statusItem.dispose();
        // handleError(ex)
        throw ex; // re-raise
    }
}
exports.activate = activate;
// tslint:disable-next-line:max-func-body-length
async function activateUnsafe(context) {
    // displayProgress(activationDeferred.promise)
    durations.startActivateTime = stopWatch.elapsedTime;
    const cont = new inversify_1.Container();
    const serviceManager = new serviceManager_1.ServiceManager(cont);
    const serviceContainer = new container_1.ServiceContainer(cont);
    activatedServiceContainer = serviceContainer;
    registerServices(context, serviceManager, serviceContainer);
    await initializeServices(context, serviceManager, serviceContainer);
    const manager = serviceContainer.get(types_1.IExtensionActivationManager);
    context.subscriptions.push(manager);
    const activationPromise = manager.activate();
    serviceManager.get(types_8.ITerminalAutoActivation).register();
    const configuration = serviceManager.get(types_4.IConfigurationService);
    const pythonSettings = configuration.getSettings();
    const standardOutputChannel = serviceContainer.get(types_4.IOutputChannel, constants_1.STANDARD_OUTPUT_CHANNEL);
    simpleRefactorProvider_1.activateSimplePythonRefactorProvider(context, standardOutputChannel, serviceContainer);
    const sortImports = serviceContainer.get(types_7.ISortImportsEditingProvider);
    sortImports.registerCommands();
    serviceManager.get(types_8.ICodeExecutionManager).registerCommands();
    // tslint:disable-next-line:no-suspicious-comment
    // TODO: Move this down to right before durations.endActivateTime is set.
    // sendStartupTelemetry(Promise.all([activationDeferred.promise, activationPromise]), serviceContainer).catch(emptyFn)
    const workspaceService = serviceContainer.get(types_3.IWorkspaceService);
    const interpreterManager = serviceContainer.get(contracts_1.IInterpreterService);
    interpreterManager.refresh(coc_nvim_1.Uri.file(coc_nvim_1.workspace.rootPath))
        // tslint:disable-next-line: no-console
        .catch(ex => console.error('Python Extension: interpreterManager.refresh', ex));
    // const jupyterExtension = extensions.getExtension('donjayamanne.jupyter')
    // const lintingEngine = serviceManager.get<ILintingEngine>(ILintingEngine)
    // lintingEngine.linkJupyterExtension(jupyterExtension).catch(emptyFn)
    context.subscriptions.push(new linterCommands_1.LinterCommands(serviceManager));
    const linterProvider = new linterProvider_1.LinterProvider(context, serviceManager);
    context.subscriptions.push(linterProvider);
    if (pythonSettings && pythonSettings.formatting && pythonSettings.formatting.provider !== 'none') {
        const formatProvider = new formatProvider_1.PythonFormattingEditProvider(context, serviceContainer);
        context.subscriptions.push(coc_nvim_1.languages.registerDocumentFormatProvider(constants_1.PYTHON, formatProvider));
        context.subscriptions.push(coc_nvim_1.languages.registerDocumentRangeFormatProvider(constants_1.PYTHON, formatProvider));
    }
    const deprecationMgr = serviceContainer.get(types_4.IFeatureDeprecationManager);
    deprecationMgr.initialize();
    context.subscriptions.push(deprecationMgr);
    context.subscriptions.push(updateSparkLibraryProvider_1.activateUpdateSparkLibraryProvider());
    context.subscriptions.push(new replProvider_1.ReplProvider(serviceContainer));
    context.subscriptions.push(new terminalProvider_1.TerminalProvider(serviceContainer));
    context.subscriptions.push(coc_nvim_1.languages.registerCodeActionProvider(constants_1.PYTHON, new codeActionsProvider_1.PythonCodeActionProvider(), 'python', [vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports]));
    durations.endActivateTime = stopWatch.elapsedTime;
    activationDeferred.resolve();
    const api = api_1.buildApi(Promise.all([activationDeferred.promise, activationPromise]));
    // In test environment return the DI Container.
    return api;
}
function deactivate() {
    // Make sure to shutdown anybody who needs it.
    if (activatedServiceContainer) {
        const registry = activatedServiceContainer.get(types_4.IAsyncDisposableRegistry);
        if (registry) {
            return registry.dispose();
        }
    }
    return Promise.resolve();
}
exports.deactivate = deactivate;
// tslint:disable-next-line:no-any
// function displayProgress(promise: Promise<any>) {
//
//   const progressOptions: ProgressOptions = { location: ProgressLocation.Window, title: Common.loadingExtension() }
//   window.withProgress(progressOptions, () => promise)
// }
//
function registerServices(context, serviceManager, serviceContainer) {
    serviceManager.addSingletonInstance(types_6.IServiceContainer, serviceContainer);
    serviceManager.addSingletonInstance(types_6.IServiceManager, serviceManager);
    serviceManager.addSingletonInstance(types_4.IDisposableRegistry, context.subscriptions);
    serviceManager.addSingletonInstance(types_4.IMemento, context.globalState, types_4.GLOBAL_MEMENTO);
    serviceManager.addSingletonInstance(types_4.IMemento, context.workspaceState, types_4.WORKSPACE_MEMENTO);
    serviceManager.addSingletonInstance(types_4.IExtensionContext, context);
    const standardOutputChannel = coc_nvim_1.workspace.createOutputChannel('Python');
    // const unitTestOutChannel = window.createOutputChannel('Python Test Log')
    serviceManager.addSingletonInstance(types_4.IOutputChannel, standardOutputChannel, constants_1.STANDARD_OUTPUT_CHANNEL);
    // serviceManager.addSingletonInstance<OutputChannel>(IOutputChannel, unitTestOutChannel, TEST_OUTPUT_CHANNEL)
    serviceRegistry_1.registerTypes(serviceManager);
    serviceRegistry_7.registerTypes(serviceManager);
    serviceRegistry_3.registerTypes(serviceManager);
    serviceRegistry_6.registerTypes(serviceManager);
    serviceRegistry_8.registerTypes(serviceManager);
    serviceRegistry_11.registerTypes(serviceManager);
    serviceRegistry_10.registerTypes(serviceManager);
    serviceRegistry_9.registerTypes(serviceManager);
    serviceRegistry_5.registerTypes(serviceManager);
    serviceRegistry_4.registerTypes(serviceManager);
    serviceRegistry_13.registerTypes(serviceManager);
    // unitTestsRegisterTypes(serviceManager)
    // dataScienceRegisterTypes(serviceManager)
    // debugConfigurationRegisterTypes(serviceManager)
    serviceRegistry_2.registerTypes(serviceManager);
    serviceRegistry_12.registerTypes(serviceManager);
}
async function initializeServices(context, serviceManager, serviceContainer) {
    const selector = serviceContainer.get(types_5.IInterpreterSelector);
    selector.initialize();
    context.subscriptions.push(selector);
    const interpreterManager = serviceContainer.get(contracts_1.IInterpreterService);
    interpreterManager.initialize();
    // const handlers = serviceManager.getAll<IDebugSessionEventHandlers>(IDebugSessionEventHandlers)
    const disposables = serviceManager.get(types_4.IDisposableRegistry);
    // const dispatcher = new DebugSessionEventDispatcher(handlers, DebugService.instance, disposables)
    // dispatcher.registerEventHandlers()
    const cmdManager = serviceContainer.get(types_3.ICommandManager);
    const outputChannel = serviceManager.get(types_4.IOutputChannel, constants_1.STANDARD_OUTPUT_CHANNEL);
    disposables.push(cmdManager.registerCommand(constants_1.Commands.ViewOutput, () => outputChannel.show()));
    // Display progress of interpreter refreshes only after extension has activated.
    serviceContainer.get(contracts_1.InterpreterLocatorProgressHandler).register();
    serviceContainer.get(contracts_1.IInterpreterLocatorProgressService).register();
    serviceContainer.get(types_2.IApplicationDiagnostics).register();
    serviceContainer.get(types_1.ILanguageServerExtension).register();
    // serviceContainer.get<ITestCodeNavigatorCommandHandler>(ITestCodeNavigatorCommandHandler).register()
    // serviceContainer.get<ITestExplorerCommandHandler>(ITestExplorerCommandHandler).register()
    // serviceContainer.get<ITestContextService>(ITestContextService).register()
}
function notifyUser(msg) {
    // tslint:disable-next-line:no-any
    coc_nvim_1.workspace.showMessage(msg, 'error');
}
//# sourceMappingURL=index.js.map