// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const inversify_1 = require("inversify");
const path_1 = __importDefault(require("path"));
const logger_1 = require("../../common/logger");
const types_1 = require("../../common/platform/types");
const types_2 = require("../../common/process/types");
const types_3 = require("../../common/terminal/types");
const types_4 = require("../../common/types");
const decorators_1 = require("../../common/utils/decorators");
const platform_1 = require("../../common/utils/platform");
const types_5 = require("../../common/variables/types");
const constants_1 = require("../../constants");
const string_1 = require("../../common/string");
const getEnvironmentPrefix = 'e8b39361-0157-4923-80e1-22d70d46dee6';
const cacheDuration = 10 * 60 * 1000;
const getEnvironmentTimeout = 30000;
// The shell under which we'll execute activation scripts.
const defaultShells = {
    [platform_1.OSType.Windows]: 'cmd',
    [platform_1.OSType.OSX]: 'bash',
    [platform_1.OSType.Linux]: 'bash',
    [platform_1.OSType.Unknown]: undefined
};
let EnvironmentActivationService = class EnvironmentActivationService {
    constructor(helper, platform, processServiceFactory, currentProcess, envVarsService) {
        this.helper = helper;
        this.platform = platform;
        this.processServiceFactory = processServiceFactory;
        this.currentProcess = currentProcess;
        this.envVarsService = envVarsService;
        this.disposables = [];
        this.envVarsService.onDidEnvironmentVariablesChange(this.onDidEnvironmentVariablesChange, this, this.disposables);
    }
    dispose() {
        this.disposables.forEach(d => d.dispose());
    }
    async getActivatedEnvironmentVariables(resource, interpreter, allowExceptions) {
        const shell = defaultShells[this.platform.osType];
        if (!shell) {
            return;
        }
        try {
            const activationCommands = await this.helper.getEnvironmentActivationShellCommands(resource, interpreter);
            logger_1.traceVerbose(`Activation Commands received ${activationCommands}`);
            if (!activationCommands || !Array.isArray(activationCommands) || activationCommands.length === 0) {
                return;
            }
            // Run the activate command collect the environment from it.
            const activationCommand = this.fixActivationCommands(activationCommands).join(' && ');
            const processService = await this.processServiceFactory.create(resource);
            const customEnvVars = await this.envVarsService.getEnvironmentVariables(resource);
            const hasCustomEnvVars = Object.keys(customEnvVars).length;
            const env = hasCustomEnvVars ? customEnvVars : this.currentProcess.env;
            logger_1.traceVerbose(`${hasCustomEnvVars ? 'Has' : 'No'} Custom Env Vars`);
            // In order to make sure we know where the environment output is,
            // put in a dummy echo we can look for
            const printEnvPyFile = path_1.default.join(constants_1.EXTENSION_ROOT_DIR, 'pythonFiles', 'printEnvVariables.py');
            const command = `${activationCommand} && echo '${getEnvironmentPrefix}' && python ${string_1.fileToCommandArgument(printEnvPyFile)}`;
            logger_1.traceVerbose(`Activating Environment to capture Environment variables, ${command}`);
            // Conda activate can hang on certain systems. Fail after 30 seconds.
            // See the discussion from hidesoon in this issue: https://github.com/Microsoft/vscode-python/issues/4424
            // His issue is conda never finishing during activate. This is a conda issue, but we
            // should at least tell the user.
            const result = await processService.shellExec(command, { env, shell, timeout: getEnvironmentTimeout, maxBuffer: 1000 * 1000 });
            if (result.stderr && result.stderr.length > 0) {
                throw new Error(`StdErr from ShellExec, ${result.stderr}`);
            }
            return this.parseEnvironmentOutput(result.stdout);
        }
        catch (e) {
            logger_1.traceError('getActivatedEnvironmentVariables', e);
            // Some callers want this to bubble out, others don't
            if (allowExceptions) {
                throw e;
            }
        }
    }
    onDidEnvironmentVariablesChange(affectedResource) {
        decorators_1.clearCachedResourceSpecificIngterpreterData('ActivatedEnvironmentVariables', affectedResource);
    }
    fixActivationCommands(commands) {
        // Replace 'source ' with '. ' as that works in shell exec
        return commands.map(cmd => cmd.replace(/^source\s+/, '. '));
    }
    parseEnvironmentOutput(output) {
        output = output.substring(output.indexOf(getEnvironmentPrefix) + getEnvironmentPrefix.length);
        const js = output.substring(output.indexOf('{')).trim();
        return JSON.parse(js);
    }
};
__decorate([
    logger_1.traceDecorators.verbose('getActivatedEnvironmentVariables', logger_1.LogOptions.Arguments),
    decorators_1.cacheResourceSpecificInterpreterData('ActivatedEnvironmentVariables', cacheDuration)
], EnvironmentActivationService.prototype, "getActivatedEnvironmentVariables", null);
__decorate([
    logger_1.traceDecorators.error('Failed to parse Environment variables'),
    logger_1.traceDecorators.verbose('parseEnvironmentOutput', logger_1.LogOptions.None)
], EnvironmentActivationService.prototype, "parseEnvironmentOutput", null);
EnvironmentActivationService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_3.ITerminalHelper)),
    __param(1, inversify_1.inject(types_1.IPlatformService)),
    __param(2, inversify_1.inject(types_2.IProcessServiceFactory)),
    __param(3, inversify_1.inject(types_4.ICurrentProcess)),
    __param(4, inversify_1.inject(types_5.IEnvironmentVariablesProvider))
], EnvironmentActivationService);
exports.EnvironmentActivationService = EnvironmentActivationService;
//# sourceMappingURL=service.js.map