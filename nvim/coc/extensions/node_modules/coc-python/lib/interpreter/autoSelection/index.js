// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const inversify_1 = require("inversify");
const semver_1 = require("semver");
const coc_nvim_1 = require("coc.nvim");
const types_1 = require("../../common/application/types");
const types_2 = require("../../common/platform/types");
const types_3 = require("../../common/types");
const async_1 = require("../../common/utils/async");
const contracts_1 = require("../contracts");
const types_4 = require("./types");
const function_1 = require("../../common/function");
const preferredGlobalInterpreter = 'preferredGlobalPyInterpreter';
const workspacePathNameForGlobalWorkspaces = '';
let InterpreterAutoSelectionService = class InterpreterAutoSelectionService {
    constructor(workspaceService, stateFactory, fs, systemInterpreter, currentPathInterpreter, winRegInterpreter, cachedPaths, userDefinedInterpreter, environmentInterpreter, workspaceInterpreter, proxy, interpreterHelper) {
        this.workspaceService = workspaceService;
        this.stateFactory = stateFactory;
        this.fs = fs;
        this.userDefinedInterpreter = userDefinedInterpreter;
        this.environmentInterpreter = environmentInterpreter;
        this.interpreterHelper = interpreterHelper;
        this.autoSelectedWorkspacePromises = new Map();
        this.didAutoSelectedInterpreterEmitter = new coc_nvim_1.Emitter();
        this.autoSelectedInterpreterByWorkspace = new Map();
        this.rules = [];
        // It is possible we area always opening the same workspace folder, but we still need to determine and cache
        // the best available interpreters based on other rules (cache for furture use).
        this.rules.push(...[winRegInterpreter, currentPathInterpreter, systemInterpreter, cachedPaths, userDefinedInterpreter, workspaceInterpreter, environmentInterpreter]);
        proxy.registerInstance(this);
        // Rules are as follows in order
        // 1. First check user settings.json
        //      If we have user settings, then always use that, do not proceed.
        // 2. Check workspace virtual environments (pipenv, etc).
        //      If we have some, then use those as preferred workspace environments.
        // 3. Check list of cached interpreters (previously cachced from all the rules).
        //      If we find a good one, use that as preferred global env.
        //      Provided its better than what we have already cached as globally preffered interpreter (globallyPreferredInterpreter).
        // 4. Check current path.
        //      If we find a good one, use that as preferred global env.
        //      Provided its better than what we have already cached as globally preffered interpreter (globallyPreferredInterpreter).
        // 5. Check windows registry.
        //      If we find a good one, use that as preferred global env.
        //      Provided its better than what we have already cached as globally preffered interpreter (globallyPreferredInterpreter).
        // 6. Check the entire system.
        //      If we find a good one, use that as preferred global env.
        //      Provided its better than what we have already cached as globally preffered interpreter (globallyPreferredInterpreter).
        userDefinedInterpreter.setNextRule(environmentInterpreter);
        environmentInterpreter.setNextRule(workspaceInterpreter);
        workspaceInterpreter.setNextRule(cachedPaths);
        cachedPaths.setNextRule(currentPathInterpreter);
        currentPathInterpreter.setNextRule(winRegInterpreter);
        winRegInterpreter.setNextRule(systemInterpreter);
    }
    async autoSelectInterpreter(resource) {
        const key = this.getWorkspacePathKey(resource);
        if (!this.autoSelectedWorkspacePromises.has(key)) {
            const deferred = async_1.createDeferred();
            this.autoSelectedWorkspacePromises.set(key, deferred);
            await this.initializeStore(resource);
            await this.clearWorkspaceStoreIfInvalid(resource);
            await this.environmentInterpreter.autoSelectInterpreter(resource, this);
            this.didAutoSelectedInterpreterEmitter.fire();
            Promise.all(this.rules.map(item => item.autoSelectInterpreter(resource))).catch(function_1.emptyFn);
            deferred.resolve();
        }
        return this.autoSelectedWorkspacePromises.get(key).promise;
    }
    get onDidChangeAutoSelectedInterpreter() {
        return this.didAutoSelectedInterpreterEmitter.event;
    }
    getAutoSelectedInterpreter(resource) {
        // Do not execute anycode other than fetching fromm a property.
        // This method gets invoked from settings class, and this class in turn uses classes that relies on settings.
        // I.e. we can end up in a recursive loop.
        const workspaceState = this.getWorkspaceState(resource);
        if (workspaceState && workspaceState.value) {
            return workspaceState.value;
        }
        const workspaceFolderPath = this.getWorkspacePathKey(resource);
        if (this.autoSelectedInterpreterByWorkspace.has(workspaceFolderPath)) {
            return this.autoSelectedInterpreterByWorkspace.get(workspaceFolderPath);
        }
        return this.globallyPreferredInterpreter.value;
    }
    async setWorkspaceInterpreter(resource, interpreter) {
        // We can only update the stored interpreter once we have done the necessary
        // work of auto selecting the interpreters.
        if (!this.autoSelectedWorkspacePromises.has(this.getWorkspacePathKey(resource)) ||
            !this.autoSelectedWorkspacePromises.get(this.getWorkspacePathKey(resource)).completed) {
            return;
        }
        await this.storeAutoSelectedInterpreter(resource, interpreter);
    }
    async setGlobalInterpreter(interpreter) {
        await this.storeAutoSelectedInterpreter(undefined, interpreter);
    }
    async clearWorkspaceStoreIfInvalid(resource) {
        const stateStore = this.getWorkspaceState(resource);
        if (stateStore && stateStore.value && !await this.fs.fileExists(stateStore.value.path)) {
            // sendTelemetryEvent(EventName.PYTHON_INTERPRETER_AUTO_SELECTION, {}, { interpreterMissing: true })
            await stateStore.updateValue(undefined);
        }
    }
    async storeAutoSelectedInterpreter(resource, interpreter) {
        const workspaceFolderPath = this.getWorkspacePathKey(resource);
        if (workspaceFolderPath === workspacePathNameForGlobalWorkspaces) {
            // Update store only if this version is better.
            if (this.globallyPreferredInterpreter.value &&
                this.globallyPreferredInterpreter.value.version &&
                interpreter && interpreter.version &&
                semver_1.compare(this.globallyPreferredInterpreter.value.version.raw, interpreter.version.raw) > 0) {
                return;
            }
            // Don't pass in manager instance, as we don't want any updates to take place.
            await this.globallyPreferredInterpreter.updateValue(interpreter);
            this.autoSelectedInterpreterByWorkspace.set(workspaceFolderPath, interpreter);
        }
        else {
            const workspaceState = this.getWorkspaceState(resource);
            if (workspaceState && interpreter) {
                await workspaceState.updateValue(interpreter);
            }
            this.autoSelectedInterpreterByWorkspace.set(workspaceFolderPath, interpreter);
        }
    }
    async initializeStore(resource) {
        const workspaceFolderPath = this.getWorkspacePathKey(resource);
        // Since we're initializing for this resource,
        // Ensure any cached information for this workspace have been removed.
        this.autoSelectedInterpreterByWorkspace.delete(workspaceFolderPath);
        if (this.globallyPreferredInterpreter) {
            return;
        }
        await this.clearStoreIfFileIsInvalid();
    }
    async clearStoreIfFileIsInvalid() {
        this.globallyPreferredInterpreter = this.stateFactory.createGlobalPersistentState(preferredGlobalInterpreter, undefined);
        if (this.globallyPreferredInterpreter.value && !await this.fs.fileExists(this.globallyPreferredInterpreter.value.path)) {
            await this.globallyPreferredInterpreter.updateValue(undefined);
        }
    }
    getWorkspacePathKey(resource) {
        return this.workspaceService.getWorkspaceFolderIdentifier(resource, workspacePathNameForGlobalWorkspaces);
    }
    getWorkspaceState(resource) {
        const workspaceUri = this.interpreterHelper.getActiveWorkspaceUri(resource);
        if (!workspaceUri) {
            return;
        }
        const key = `autoSelectedWorkspacePythonInterpreter-${workspaceUri.folderUri.fsPath}`;
        return this.stateFactory.createWorkspacePersistentState(key, undefined);
    }
};
InterpreterAutoSelectionService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_1.IWorkspaceService)),
    __param(1, inversify_1.inject(types_3.IPersistentStateFactory)),
    __param(2, inversify_1.inject(types_2.IFileSystem)),
    __param(3, inversify_1.inject(types_4.IInterpreterAutoSelectionRule)), __param(3, inversify_1.named(types_4.AutoSelectionRule.systemWide)),
    __param(4, inversify_1.inject(types_4.IInterpreterAutoSelectionRule)), __param(4, inversify_1.named(types_4.AutoSelectionRule.currentPath)),
    __param(5, inversify_1.inject(types_4.IInterpreterAutoSelectionRule)), __param(5, inversify_1.named(types_4.AutoSelectionRule.windowsRegistry)),
    __param(6, inversify_1.inject(types_4.IInterpreterAutoSelectionRule)), __param(6, inversify_1.named(types_4.AutoSelectionRule.cachedInterpreters)),
    __param(7, inversify_1.inject(types_4.IInterpreterAutoSelectionRule)), __param(7, inversify_1.named(types_4.AutoSelectionRule.settings)),
    __param(8, inversify_1.inject(types_4.IInterpreterAutoSelectionRule)), __param(8, inversify_1.named(types_4.AutoSelectionRule.environment)),
    __param(9, inversify_1.inject(types_4.IInterpreterAutoSelectionRule)), __param(9, inversify_1.named(types_4.AutoSelectionRule.workspaceVirtualEnvs)),
    __param(10, inversify_1.inject(types_4.IInterpreterAutoSeletionProxyService)),
    __param(11, inversify_1.inject(contracts_1.IInterpreterHelper))
], InterpreterAutoSelectionService);
exports.InterpreterAutoSelectionService = InterpreterAutoSelectionService;
//# sourceMappingURL=index.js.map