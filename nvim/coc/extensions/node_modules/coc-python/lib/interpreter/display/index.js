"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const inversify_1 = require("inversify");
const types_1 = require("../../common/application/types");
const types_2 = require("../../common/types");
const types_3 = require("../../ioc/types");
const types_4 = require("../autoSelection/types");
const contracts_1 = require("../contracts");
const function_1 = require("../../common/function");
// tslint:disable-next-line:completed-docs
let InterpreterDisplay = class InterpreterDisplay {
    constructor(serviceContainer) {
        this.helper = serviceContainer.get(contracts_1.IInterpreterHelper);
        this.workspaceService = serviceContainer.get(types_1.IWorkspaceService);
        this.interpreterService = serviceContainer.get(contracts_1.IInterpreterService);
        this.autoSelection = serviceContainer.get(types_4.IInterpreterAutoSelectionService);
        const application = serviceContainer.get(types_1.IApplicationShell);
        const disposableRegistry = serviceContainer.get(types_2.IDisposableRegistry);
        this.statusBar = application.createStatusBarItem(100);
        this.statusBar.text = 'python';
        // this.statusBar.command = 'python.setInterpreter'
        disposableRegistry.push(this.statusBar);
        this.interpreterService.onDidChangeInterpreterInformation(this.onDidChangeInterpreterInformation, this, disposableRegistry);
    }
    async refresh(resource) {
        // Use the workspace Uri if available
        if (resource && this.workspaceService.getWorkspaceFolder(resource)) {
            resource = coc_nvim_1.Uri.parse(this.workspaceService.getWorkspaceFolder(resource).uri);
        }
        if (!resource) {
            const wkspc = this.helper.getActiveWorkspaceUri(resource);
            resource = wkspc ? wkspc.folderUri : undefined;
        }
        await this.updateDisplay(resource);
    }
    onDidChangeInterpreterInformation(info) {
        if (!this.currentlySelectedInterpreterPath || this.currentlySelectedInterpreterPath === info.path) {
            this.updateDisplay(this.currentlySelectedWorkspaceFolder).catch(function_1.emptyFn);
        }
    }
    async updateDisplay(workspaceFolder) {
        await this.autoSelection.autoSelectInterpreter(workspaceFolder);
        const interpreter = await this.interpreterService.getActiveInterpreter(workspaceFolder);
        this.currentlySelectedWorkspaceFolder = workspaceFolder;
        if (interpreter) {
            this.statusBar.text = interpreter.displayName;
            this.currentlySelectedInterpreterPath = interpreter.path;
        }
        else {
            this.statusBar.text = 'No Python Interpreter';
            this.currentlySelectedInterpreterPath = undefined;
        }
        this.statusBar.show();
    }
};
InterpreterDisplay = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_3.IServiceContainer))
], InterpreterDisplay);
exports.InterpreterDisplay = InterpreterDisplay;
//# sourceMappingURL=index.js.map