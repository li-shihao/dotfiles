"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const inversify_1 = require("inversify");
const md5_1 = __importDefault(require("md5"));
const path_1 = __importDefault(require("path"));
const coc_nvim_1 = require("coc.nvim");
const types_1 = require("../common/application/types");
const registry_1 = require("../common/platform/registry");
const types_2 = require("../common/platform/types");
const types_3 = require("../common/process/types");
const types_4 = require("../common/types");
const async_1 = require("../common/utils/async");
const types_5 = require("../ioc/types");
const contracts_1 = require("./contracts");
const types_6 = require("./virtualEnvs/types");
const function_1 = require("../common/function");
const EXPITY_DURATION = 24 * 60 * 60 * 1000;
let InterpreterService = class InterpreterService {
    constructor(serviceContainer) {
        this.serviceContainer = serviceContainer;
        this.didChangeInterpreterEmitter = new coc_nvim_1.Emitter();
        this.didChangeInterpreterInformation = new coc_nvim_1.Emitter();
        this.inMemoryCacheOfDisplayNames = new Map();
        this.updatedInterpreters = new Set();
        this.pythonPathSetting = '';
        this.onConfigChanged = () => {
            // Check if we actually changed our python path
            const pySettings = this.configService.getSettings();
            if (this.pythonPathSetting !== pySettings.pythonPath) {
                this.pythonPathSetting = pySettings.pythonPath;
                this.didChangeInterpreterEmitter.fire();
                const interpreterDisplay = this.serviceContainer.get(contracts_1.IInterpreterDisplay);
                // tslint:disable-next-line: no-console
                interpreterDisplay.refresh().catch(ex => console.error('Python Extension: display.refresh', ex));
            }
        };
        this.locator = serviceContainer.get(contracts_1.IInterpreterLocatorService, contracts_1.INTERPRETER_LOCATOR_SERVICE);
        this.fs = this.serviceContainer.get(types_2.IFileSystem);
        this.persistentStateFactory = this.serviceContainer.get(types_4.IPersistentStateFactory);
        this.configService = this.serviceContainer.get(types_4.IConfigurationService);
    }
    get hasInterpreters() {
        return this.locator.hasInterpreters;
    }
    async refresh(resource) {
        const interpreterDisplay = this.serviceContainer.get(contracts_1.IInterpreterDisplay);
        return interpreterDisplay.refresh(resource);
    }
    initialize() {
        const disposables = this.serviceContainer.get(types_4.IDisposableRegistry);
        // const documentManager = this.serviceContainer.get<IDocumentManager>(IDocumentManager)
        coc_nvim_1.events.on('BufEnter', async (bufnr) => {
            let doc = coc_nvim_1.workspace.getDocument(bufnr);
            if (doc && doc.filetype == 'python') {
                await this.refresh(coc_nvim_1.Uri.parse(doc.uri));
            }
        }, null, disposables);
        // disposables.push(documentManager.onDidChangeActiveTextEditor(e => e ? this.refresh(e.document.uri) : undefined))
        const workspaceService = this.serviceContainer.get(types_1.IWorkspaceService);
        const pySettings = this.configService.getSettings();
        this.pythonPathSetting = pySettings.pythonPath;
        const disposable = workspaceService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('python.pythonPath', undefined)) {
                this.onConfigChanged();
            }
        });
        disposables.push(disposable);
    }
    async getInterpreters(resource) {
        const interpreters = await this.locator.getInterpreters(resource);
        await Promise.all(interpreters
            .filter(item => !item.displayName)
            .map(async (item) => {
            item.displayName = await this.getDisplayName(item, resource);
            // Keep information up to date with latest details.
            if (!item.cachedEntry) {
                this.updateCachedInterpreterInformation(item, resource).catch(function_1.emptyFn);
            }
        }));
        return interpreters;
    }
    dispose() {
        this.locator.dispose();
        this.didChangeInterpreterEmitter.dispose();
        this.didChangeInterpreterInformation.dispose();
    }
    get onDidChangeInterpreter() {
        return this.didChangeInterpreterEmitter.event;
    }
    get onDidChangeInterpreterInformation() {
        return this.didChangeInterpreterInformation.event;
    }
    async getActiveInterpreter(resource) {
        const pythonExecutionFactory = this.serviceContainer.get(types_3.IPythonExecutionFactory);
        const pythonExecutionService = await pythonExecutionFactory.create({ resource });
        const fullyQualifiedPath = await pythonExecutionService.getExecutablePath().catch(() => undefined);
        // Python path is invalid or python isn't installed.
        if (!fullyQualifiedPath) {
            return;
        }
        return this.getInterpreterDetails(fullyQualifiedPath, resource);
    }
    async getInterpreterDetails(pythonPath, resource) {
        // If we don't have the fully qualified path, then get it.
        if (path_1.default.basename(pythonPath) === pythonPath) {
            const pythonExecutionFactory = this.serviceContainer.get(types_3.IPythonExecutionFactory);
            const pythonExecutionService = await pythonExecutionFactory.create({ resource });
            pythonPath = await pythonExecutionService.getExecutablePath().catch(() => '');
            // Python path is invalid or python isn't installed.
            if (!pythonPath) {
                return;
            }
        }
        const store = await this.getInterpreterCache(pythonPath);
        if (store.value && store.value.info) {
            return store.value.info;
        }
        const fs = this.serviceContainer.get(types_2.IFileSystem);
        // Don't want for all interpreters are collected.
        // Try to collect the infromation manually, that's faster.
        // Get from which ever comes first.
        const option1 = (async () => {
            const result = this.collectInterpreterDetails(pythonPath, resource);
            await async_1.sleep(1000); // let the other option complete within 1s if possible.
            return result;
        })();
        // This is the preferred approach, hence the delay in option 1.
        const option2 = (async () => {
            const interpreters = await this.getInterpreters(resource);
            const found = interpreters.find(i => fs.arePathsSame(i.path, pythonPath));
            if (found) {
                // Cache the interpreter info, only if we get the data from interpretr list.
                // tslint:disable-next-line:no-any
                found.__store = true;
                return found;
            }
            // Use option1 as a fallback.
            // tslint:disable-next-line:no-any
            return option1;
        })();
        const interpreterInfo = await Promise.race([option2, option1]);
        // tslint:disable-next-line:no-any
        if (interpreterInfo && interpreterInfo.__store) {
            await this.updateCachedInterpreterInformation(interpreterInfo, resource);
        }
        else {
            // If we got information from option1, then when option2 finishes cache it for later use (ignoring erors)
            option2.then(async (info) => {
                // tslint:disable-next-line:no-any
                if (info && info.__store) {
                    await this.updateCachedInterpreterInformation(info, resource);
                }
            }).catch(function_1.emptyFn);
        }
        return interpreterInfo;
    }
    /**
     * Gets the display name of an interpreter.
     * The format is `Python <Version> <bitness> (<env name>: <env type>)`
     * E.g. `Python 3.5.1 32-bit (myenv2: virtualenv)`
     * @param {Partial<PythonInterpreter>} info
     * @returns {string}
     * @memberof InterpreterService
     */
    async getDisplayName(info, resource) {
        // faster than calculating file has agian and again, only when deailing with cached items.
        if (!info.cachedEntry && info.path && this.inMemoryCacheOfDisplayNames.has(info.path)) {
            return this.inMemoryCacheOfDisplayNames.get(info.path);
        }
        const fileHash = (info.path ? await this.fs.getFileHash(info.path).catch(() => '') : '') || '';
        // Do not include dipslay name into hash as that changes.
        const interpreterHash = `${fileHash}-${md5_1.default(JSON.stringify(Object.assign({}, info, { displayName: '' })))}`;
        const store = this.persistentStateFactory.createGlobalPersistentState(`${info.path}.interpreter.displayName.v7`, undefined, EXPITY_DURATION);
        if (store.value && store.value.hash === interpreterHash && store.value.displayName) {
            this.inMemoryCacheOfDisplayNames.set(info.path, store.value.displayName);
            return store.value.displayName;
        }
        const displayName = await this.buildInterpreterDisplayName(info, resource);
        // If dealing with cached entry, then do not store the display name in cache.
        if (!info.cachedEntry) {
            await store.updateValue({ displayName, hash: interpreterHash });
            this.inMemoryCacheOfDisplayNames.set(info.path, displayName);
        }
        return displayName;
    }
    async getInterpreterCache(pythonPath) {
        const fileHash = (pythonPath ? await this.fs.getFileHash(pythonPath).catch(() => '') : '') || '';
        const store = this.persistentStateFactory.createGlobalPersistentState(`${pythonPath}.interpreter.Details.v7`, undefined, EXPITY_DURATION);
        if (!store.value || store.value.fileHash !== fileHash) {
            await store.updateValue({ fileHash });
        }
        return store;
    }
    async updateCachedInterpreterInformation(info, resource) {
        const key = JSON.stringify(info);
        if (this.updatedInterpreters.has(key)) {
            return;
        }
        this.updatedInterpreters.add(key);
        const state = await this.getInterpreterCache(info.path);
        info.displayName = await this.getDisplayName(info, resource);
        // Check if info has indeed changed.
        if (state.value && state.value.info &&
            JSON.stringify(info) === JSON.stringify(state.value.info)) {
            return;
        }
        this.inMemoryCacheOfDisplayNames.delete(info.path);
        await state.updateValue({ fileHash: state.value.fileHash, info });
        this.didChangeInterpreterInformation.fire(info);
    }
    async buildInterpreterDisplayName(info, resource) {
        const displayNameParts = ['Python'];
        const envSuffixParts = [];
        if (info.version) {
            displayNameParts.push(`${info.version.major}.${info.version.minor}.${info.version.patch}`);
        }
        if (info.architecture) {
            displayNameParts.push(registry_1.getArchitectureDisplayName(info.architecture));
        }
        if (!info.envName && info.path && info.type && info.type === contracts_1.InterpreterType.Pipenv) {
            // If we do not have the name of the environment, then try to get it again.
            // This can happen based on the context (i.e. resource).
            // I.e. we can determine if an environment is PipEnv only when giving it the right workspacec path (i.e. resource).
            const virtualEnvMgr = this.serviceContainer.get(types_6.IVirtualEnvironmentManager);
            info.envName = await virtualEnvMgr.getEnvironmentName(info.path, resource);
        }
        if (info.envName && info.envName.length > 0) {
            envSuffixParts.push(`'${info.envName}'`);
        }
        if (info.type) {
            const interpreterHelper = this.serviceContainer.get(contracts_1.IInterpreterHelper);
            const name = interpreterHelper.getInterpreterTypeDisplayName(info.type);
            if (name) {
                envSuffixParts.push(name);
            }
        }
        const envSuffix = envSuffixParts.length === 0 ? '' :
            `(${envSuffixParts.join(': ')})`;
        return `${displayNameParts.join(' ')} ${envSuffix}`.trim();
    }
    async collectInterpreterDetails(pythonPath, resource) {
        const interpreterHelper = this.serviceContainer.get(contracts_1.IInterpreterHelper);
        const virtualEnvManager = this.serviceContainer.get(types_6.IVirtualEnvironmentManager);
        const [info, type] = await Promise.all([
            interpreterHelper.getInterpreterInformation(pythonPath),
            virtualEnvManager.getEnvironmentType(pythonPath)
        ]);
        if (!info) {
            return;
        }
        const details = Object.assign({}, info, { path: pythonPath, type });
        const envName = type === contracts_1.InterpreterType.Unknown ? undefined : await virtualEnvManager.getEnvironmentName(pythonPath, resource);
        const pthonInfo = Object.assign({}, details, { envName });
        pthonInfo.displayName = await this.getDisplayName(pthonInfo, resource);
        return pthonInfo;
    }
};
InterpreterService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_5.IServiceContainer))
], InterpreterService);
exports.InterpreterService = InterpreterService;
//# sourceMappingURL=interpreterService.js.map