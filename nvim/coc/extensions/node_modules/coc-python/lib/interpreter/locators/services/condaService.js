"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const inversify_1 = require("inversify");
const path = __importStar(require("path"));
const semver_1 = require("semver");
const types_1 = require("../../../common/application/types");
const logger_1 = require("../../../common/logger");
const types_2 = require("../../../common/platform/types");
const types_3 = require("../../../common/process/types");
const types_4 = require("../../../common/types");
const contracts_1 = require("../../contracts");
const condaHelper_1 = require("./condaHelper");
// tslint:disable-next-line:no-require-imports no-var-requires
const untildify = require('untildify');
// This glob pattern will match all of the following:
// ~/anaconda/bin/conda, ~/anaconda3/bin/conda, ~/miniconda/bin/conda, ~/miniconda3/bin/conda
// /usr/share/anaconda/bin/conda, /usr/share/anaconda3/bin/conda, /usr/share/miniconda/bin/conda, /usr/share/miniconda3/bin/conda
const condaGlobPathsForLinuxMac = [
    '/opt/*conda*/bin/conda',
    '/usr/share/*conda*/bin/conda',
    untildify('~/*conda*/bin/conda')
];
exports.CondaLocationsGlob = `{${condaGlobPathsForLinuxMac.join(',')}}`;
// ...and for windows, the known default install locations:
const condaGlobPathsForWindows = [
    '/ProgramData/[Mm]iniconda*/Scripts/conda.exe',
    '/ProgramData/[Aa]naconda*/Scripts/conda.exe',
    untildify('~/[Mm]iniconda*/Scripts/conda.exe'),
    untildify('~/[Aa]naconda*/Scripts/conda.exe'),
    untildify('~/AppData/Local/Continuum/[Mm]iniconda*/Scripts/conda.exe'),
    untildify('~/AppData/Local/Continuum/[Aa]naconda*/Scripts/conda.exe')
];
// format for glob processing:
exports.CondaLocationsGlobWin = `{${condaGlobPathsForWindows.join(',')}}`;
exports.CondaGetEnvironmentPrefix = 'Outputting Environment Now...';
/**
 * A wrapper around a conda installation.
 */
let CondaService = class CondaService {
    constructor(processServiceFactory, platform, fileSystem, persistentStateFactory, configService, logger, disposableRegistry, workspaceService, registryLookupForConda) {
        this.processServiceFactory = processServiceFactory;
        this.platform = platform;
        this.fileSystem = fileSystem;
        this.persistentStateFactory = persistentStateFactory;
        this.configService = configService;
        this.logger = logger;
        this.disposableRegistry = disposableRegistry;
        this.workspaceService = workspaceService;
        this.registryLookupForConda = registryLookupForConda;
        this.condaHelper = new condaHelper_1.CondaHelper();
        this.addCondaPathChangedHandler();
    }
    get condaEnvironmentsFile() {
        const homeDir = this.platform.isWindows ? process.env.USERPROFILE : (process.env.HOME || process.env.HOMEPATH);
        return homeDir ? path.join(homeDir, '.conda', 'environments.txt') : undefined;
    }
    /**
     * Release any held resources.
     *
     * Called by VS Code to indicate it is done with the resource.
     */
    // tslint:disable-next-line:no-empty
    dispose() { }
    /**
     * Return the path to the "conda file".
     */
    async getCondaFile() {
        if (!this.condaFile) {
            this.condaFile = this.getCondaFileImpl();
        }
        // tslint:disable-next-line:no-unnecessary-local-variable
        const condaFile = await this.condaFile;
        return condaFile;
    }
    /**
     * Is there a conda install to use?
     */
    async isCondaAvailable() {
        if (typeof this.isAvailable === 'boolean') {
            return this.isAvailable;
        }
        return this.getCondaVersion()
            .then(version => this.isAvailable = version !== undefined)
            .catch(() => this.isAvailable = false);
    }
    /**
     * Return the conda version.
     */
    async getCondaVersion() {
        const processService = await this.processServiceFactory.create();
        const info = await this.getCondaInfo().catch(() => undefined);
        let versionString;
        if (info && info.conda_version) {
            versionString = info.conda_version;
        }
        else {
            const stdOut = await this.getCondaFile()
                .then(condaFile => processService.exec(condaFile, ['--version'], {}))
                .then(result => result.stdout.trim())
                .catch(() => undefined);
            versionString = (stdOut && stdOut.startsWith('conda ')) ? stdOut.substring('conda '.length).trim() : stdOut;
        }
        if (!versionString) {
            return;
        }
        const version = semver_1.parse(versionString, true);
        if (version) {
            return version;
        }
        // Use a bogus version, at least to indicate the fact that a version was returned.
        logger_1.Logger.warn(`Unable to parse Version of Conda, ${versionString}`);
        return new semver_1.SemVer('0.0.1');
    }
    /**
     * Can the shell find conda (to run it)?
     */
    async isCondaInCurrentPath() {
        const processService = await this.processServiceFactory.create();
        return processService.exec('conda', ['--version'])
            .then(output => output.stdout.length > 0)
            .catch(() => false);
    }
    /**
     * Return the info reported by the conda install.
     */
    async getCondaInfo() {
        try {
            const condaFile = await this.getCondaFile();
            const processService = await this.processServiceFactory.create();
            const condaInfo = await processService.exec(condaFile, ['info', '--json']).then(output => output.stdout);
            return JSON.parse(condaInfo);
        }
        catch (ex) {
            // Failed because either:
            //   1. conda is not installed.
            //   2. `conda info --json` has changed signature.
        }
    }
    /**
     * Determines whether a python interpreter is a conda environment or not.
     * The check is done by simply looking for the 'conda-meta' directory.
     * @param {string} interpreterPath
     * @returns {Promise<boolean>}
     * @memberof CondaService
     */
    async isCondaEnvironment(interpreterPath) {
        const dir = path.dirname(interpreterPath);
        const isWindows = this.platform.isWindows;
        const condaMetaDirectory = isWindows ? path.join(dir, 'conda-meta') : path.join(dir, '..', 'conda-meta');
        return this.fileSystem.directoryExists(condaMetaDirectory);
    }
    /**
     * Return (env name, interpreter filename) for the interpreter.
     */
    async getCondaEnvironment(interpreterPath) {
        const isCondaEnv = await this.isCondaEnvironment(interpreterPath);
        if (!isCondaEnv) {
            return;
        }
        let environments = await this.getCondaEnvironments(false);
        const dir = path.dirname(interpreterPath);
        // If interpreter is in bin or Scripts, then go up one level
        const subDirName = path.basename(dir);
        const goUpOnLevel = ['BIN', 'SCRIPTS'].indexOf(subDirName.toUpperCase()) !== -1;
        const interpreterPathToMatch = goUpOnLevel ? path.join(dir, '..') : dir;
        // From the list of conda environments find this dir.
        let matchingEnvs = Array.isArray(environments) ? environments.filter(item => this.fileSystem.arePathsSame(item.path, interpreterPathToMatch)) : [];
        if (matchingEnvs.length === 0) {
            environments = await this.getCondaEnvironments(true);
            matchingEnvs = Array.isArray(environments) ? environments.filter(item => this.fileSystem.arePathsSame(item.path, interpreterPathToMatch)) : [];
        }
        if (matchingEnvs.length > 0) {
            return { name: matchingEnvs[0].name, path: interpreterPathToMatch };
        }
        // If still not available, then the user created the env after starting vs code.
        // The only solution is to get the user to re-start vscode.
    }
    /**
     * Return the list of conda envs (by name, interpreter filename).
     */
    async getCondaEnvironments(ignoreCache) {
        // Global cache.
        // tslint:disable-next-line:no-any
        const globalPersistence = this.persistentStateFactory.createGlobalPersistentState('CONDA_ENVIRONMENTS', undefined);
        if (!ignoreCache && globalPersistence.value) {
            return globalPersistence.value.data;
        }
        try {
            const condaFile = await this.getCondaFile();
            const processService = await this.processServiceFactory.create();
            const envInfo = await processService.exec(condaFile, ['env', 'list']).then(output => output.stdout);
            const environments = this.condaHelper.parseCondaEnvironmentNames(envInfo);
            await globalPersistence.updateValue({ data: environments });
            return environments;
        }
        catch (ex) {
            await globalPersistence.updateValue({ data: undefined });
            // Failed because either:
            //   1. conda is not installed.
            //   2. `conda env list has changed signature.
            this.logger.logInformation('Failed to get conda environment list from conda', ex);
        }
    }
    /**
     * Return the interpreter's filename for the given environment.
     */
    getInterpreterPath(condaEnvironmentPath) {
        // where to find the Python binary within a conda env.
        const relativePath = this.platform.isWindows ? 'python.exe' : path.join('bin', 'python');
        return path.join(condaEnvironmentPath, relativePath);
    }
    /**
     * Get the conda exe from the path to an interpreter's python. This might be different than the globally registered conda.exe
     */
    async getCondaFileFromInterpreter(interpreterPath, envName) {
        const condaExe = this.platform.isWindows ? 'conda.exe' : 'conda';
        const scriptsDir = this.platform.isWindows ? 'Scripts' : 'bin';
        const interpreterDir = interpreterPath ? path.dirname(interpreterPath) : '';
        let condaPath = path.join(interpreterDir, condaExe);
        if (await this.fileSystem.fileExists(condaPath)) {
            return condaPath;
        }
        // Conda path has changed locations, check the new location in the scripts directory after checking
        // the old location
        condaPath = path.join(interpreterDir, scriptsDir, condaExe);
        if (await this.fileSystem.fileExists(condaPath)) {
            return condaPath;
        }
        // Might be in a situation where this is not the default python env, but rather one running
        // from a virtualenv
        const envsPos = envName ? interpreterDir.indexOf(path.join('envs', envName)) : -1;
        if (envsPos > 0) {
            // This should be where the original python was run from when the environment was created.
            const originalPath = interpreterDir.slice(0, envsPos);
            condaPath = path.join(originalPath, condaExe);
            if (await this.fileSystem.fileExists(condaPath)) {
                return condaPath;
            }
            // Also look in the scripts directory here too.
            condaPath = path.join(originalPath, scriptsDir, condaExe);
            if (await this.fileSystem.fileExists(condaPath)) {
                return condaPath;
            }
        }
    }
    /**
     * Is the given interpreter from conda?
     */
    detectCondaEnvironment(interpreter) {
        return interpreter.type === contracts_1.InterpreterType.Conda ||
            (interpreter.displayName ? interpreter.displayName : '').toUpperCase().indexOf('ANACONDA') >= 0 ||
            (interpreter.companyDisplayName ? interpreter.companyDisplayName : '').toUpperCase().indexOf('ANACONDA') >= 0 ||
            (interpreter.companyDisplayName ? interpreter.companyDisplayName : '').toUpperCase().indexOf('CONTINUUM') >= 0;
    }
    /**
     * Return the highest Python version from the given list.
     */
    getLatestVersion(interpreters) {
        const sortedInterpreters = interpreters.slice();
        // tslint:disable-next-line:no-non-null-assertion
        sortedInterpreters.sort((a, b) => (a.version && b.version) ? semver_1.compare(a.version.raw, b.version.raw) : 0);
        if (sortedInterpreters.length > 0) {
            return sortedInterpreters[sortedInterpreters.length - 1];
        }
    }
    addCondaPathChangedHandler() {
        const disposable = this.workspaceService.onDidChangeConfiguration(this.onDidChangeConfiguration.bind(this));
        this.disposableRegistry.push(disposable);
    }
    async onDidChangeConfiguration(event) {
        const workspacesUris = this.workspaceService.hasWorkspaceFolders ? this.workspaceService.workspaceFolders.map(workspace => workspace.uri) : [undefined];
        if (workspacesUris.findIndex(uri => event.affectsConfiguration('python.condaPath', uri)) === -1) {
            return;
        }
        this.condaFile = undefined;
    }
    /**
     * Return the path to the "conda file", if there is one (in known locations).
     */
    async getCondaFileImpl() {
        const settings = this.configService.getSettings();
        const setting = settings.condaPath;
        if (setting && setting !== '') {
            return setting;
        }
        const isAvailable = await this.isCondaInCurrentPath();
        if (isAvailable) {
            return 'conda';
        }
        if (this.platform.isWindows && this.registryLookupForConda) {
            const interpreters = await this.registryLookupForConda.getInterpreters();
            const condaInterpreters = interpreters.filter(this.detectCondaEnvironment);
            const condaInterpreter = this.getLatestVersion(condaInterpreters);
            if (condaInterpreter) {
                const interpreterPath = await this.getCondaFileFromInterpreter(condaInterpreter.path, condaInterpreter.envName);
                if (interpreterPath) {
                    return interpreterPath;
                }
            }
        }
        return this.getCondaFileFromKnownLocations();
    }
    /**
     * Return the path to the "conda file", if there is one (in known locations).
     * Note: For now we simply return the first one found.
     */
    async getCondaFileFromKnownLocations() {
        const globPattern = this.platform.isWindows ? exports.CondaLocationsGlobWin : exports.CondaLocationsGlob;
        const condaFiles = await this.fileSystem.search(globPattern)
            .catch(failReason => {
            logger_1.Logger.warn('Default conda location search failed.', `Searching for default install locations for conda results in error: ${failReason}`);
            return [];
        });
        const validCondaFiles = condaFiles.filter(condaPath => condaPath.length > 0);
        return validCondaFiles.length === 0 ? 'conda' : validCondaFiles[0];
    }
};
CondaService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_3.IProcessServiceFactory)),
    __param(1, inversify_1.inject(types_2.IPlatformService)),
    __param(2, inversify_1.inject(types_2.IFileSystem)),
    __param(3, inversify_1.inject(types_4.IPersistentStateFactory)),
    __param(4, inversify_1.inject(types_4.IConfigurationService)),
    __param(5, inversify_1.inject(types_4.ILogger)),
    __param(6, inversify_1.inject(types_4.IDisposableRegistry)),
    __param(7, inversify_1.inject(types_1.IWorkspaceService)),
    __param(8, inversify_1.inject(contracts_1.IInterpreterLocatorService)), __param(8, inversify_1.named(contracts_1.WINDOWS_REGISTRY_SERVICE)), __param(8, inversify_1.optional())
], CondaService);
exports.CondaService = CondaService;
//# sourceMappingURL=condaService.js.map