"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-require-imports no-var-requires underscore-consistent-invocation no-unnecessary-callback-wrapper
const inversify_1 = require("inversify");
const logger_1 = require("../../../common/logger");
const types_1 = require("../../../common/platform/types");
const types_2 = require("../../../common/process/types");
const types_3 = require("../../../common/types");
const platform_1 = require("../../../common/utils/platform");
const types_4 = require("../../../ioc/types");
const contracts_1 = require("../../contracts");
const types_5 = require("../types");
const cacheableLocatorService_1 = require("./cacheableLocatorService");
/**
 * Locates the currently configured Python interpreter.
 *
 * If no interpreter is configured then it falls back to the system
 * Python (3 then 2).
 */
let CurrentPathService = class CurrentPathService extends cacheableLocatorService_1.CacheableLocatorService {
    constructor(helper, processServiceFactory, pythonCommandProvider, serviceContainer) {
        super('CurrentPathService', serviceContainer);
        this.helper = helper;
        this.processServiceFactory = processServiceFactory;
        this.pythonCommandProvider = pythonCommandProvider;
        this.fs = serviceContainer.get(types_1.IFileSystem);
    }
    /**
     * Release any held resources.
     *
     * Called by VS Code to indicate it is done with the resource.
     */
    // tslint:disable-next-line:no-empty
    dispose() { }
    /**
     * Return the located interpreters.
     *
     * This is used by CacheableLocatorService.getInterpreters().
     */
    getInterpretersImplementation(resource) {
        return this.suggestionsFromKnownPaths(resource);
    }
    /**
     * Return the located interpreters.
     */
    async suggestionsFromKnownPaths(resource) {
        const configSettings = this.serviceContainer.get(types_3.IConfigurationService).getSettings(resource);
        const pathsToCheck = [...this.pythonCommandProvider.getCommands(), { command: configSettings.pythonPath }];
        const pythonPaths = Promise.all(pathsToCheck.map(item => this.getInterpreter(item)));
        return pythonPaths
            .then(interpreters => interpreters.filter(item => item.length > 0))
            // tslint:disable-next-line:promise-function-async
            .then(interpreters => Promise.all(interpreters.map(interpreter => this.getInterpreterDetails(interpreter))))
            .then(interpreters => interpreters.filter(item => !!item).map(item => item));
    }
    /**
     * Return the information about the identified interpreter binary.
     */
    async getInterpreterDetails(pythonPath) {
        return this.helper.getInterpreterInformation(pythonPath)
            .then(details => {
            if (!details) {
                return;
            }
            this._hasInterpreters.resolve(true);
            return Object.assign({}, details, { path: pythonPath, type: details.type ? details.type : contracts_1.InterpreterType.Unknown });
        });
    }
    /**
     * Return the path to the interpreter (or the default if not found).
     */
    async getInterpreter(options) {
        try {
            const processService = await this.processServiceFactory.create();
            const args = Array.isArray(options.args) ? options.args : [];
            return processService.exec(options.command, args.concat(['-c', 'import sys;print(sys.executable)']), {})
                .then(output => output.stdout.trim())
                .then(async (value) => {
                if (value.length > 0 && await this.fs.fileExists(value)) {
                    return value;
                }
                logger_1.traceError(`Detection of Python Interpreter for Command ${options.command} and args ${args.join(' ')} failed as file ${value} does not exist`);
                return '';
            })
                .catch(_ex => {
                logger_1.traceInfo(`Detection of Python Interpreter for Command ${options.command} and args ${args.join(' ')} failed`);
                return '';
            }); // Ignore exceptions in getting the executable.
        }
        catch (ex) {
            logger_1.traceError(`Detection of Python Interpreter for Command ${options.command} failed`, ex);
            return ''; // Ignore exceptions in getting the executable.
        }
    }
};
CurrentPathService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(contracts_1.IInterpreterHelper)),
    __param(1, inversify_1.inject(types_2.IProcessServiceFactory)),
    __param(2, inversify_1.inject(types_5.IPythonInPathCommandProvider)),
    __param(3, inversify_1.inject(types_4.IServiceContainer))
], CurrentPathService);
exports.CurrentPathService = CurrentPathService;
let PythonInPathCommandProvider = class PythonInPathCommandProvider {
    constructor(platform) {
        this.platform = platform;
    }
    getCommands() {
        const paths = ['python3.7', 'python3.6', 'python3', 'python2', 'python']
            .map(item => ({ command: item }));
        if (this.platform.osType !== platform_1.OSType.Windows) {
            return paths;
        }
        const versions = ['3.7', '3.6', '3', '2'];
        return paths.concat(versions.map(version => {
            return { command: 'py', args: [`-${version}`] };
        }));
    }
};
PythonInPathCommandProvider = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_1.IPlatformService))
], PythonInPathCommandProvider);
exports.PythonInPathCommandProvider = PythonInPathCommandProvider;
//# sourceMappingURL=currentPathService.js.map