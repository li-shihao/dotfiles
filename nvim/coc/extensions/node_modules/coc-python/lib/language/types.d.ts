export interface ITextRange {
    readonly start: number;
    readonly end: number;
    readonly length: number;
    contains(position: number): boolean;
}
export declare class TextRange implements ITextRange {
    static readonly empty: TextRange;
    readonly start: number;
    readonly length: number;
    constructor(start: number, length: number);
    static fromBounds(start: number, end: number): TextRange;
    readonly end: number;
    contains(position: number): boolean;
}
export interface ITextRangeCollection<T> extends ITextRange {
    count: number;
    getItemAt(index: number): T;
    getItemAtPosition(position: number): number;
    getItemContaining(position: number): number;
}
export interface ITextIterator {
    readonly length: number;
    charCodeAt(index: number): number;
    getText(): string;
}
export interface ICharacterStream extends ITextIterator {
    position: number;
    readonly currentChar: number;
    readonly nextChar: number;
    readonly prevChar: number;
    getText(): string;
    isEndOfStream(): boolean;
    lookAhead(offset: number): number;
    advance(offset: number): void;
    moveNext(): boolean;
    isAtWhiteSpace(): boolean;
    isAtLineBreak(): boolean;
    isAtString(): boolean;
    skipLineBreak(): void;
    skipWhitespace(): void;
    skipToEol(): void;
    skipToWhitespace(): void;
}
export declare enum TokenType {
    Unknown = 0,
    String = 1,
    Comment = 2,
    Keyword = 3,
    Number = 4,
    Identifier = 5,
    Operator = 6,
    Colon = 7,
    Semicolon = 8,
    Comma = 9,
    OpenBrace = 10,
    CloseBrace = 11,
    OpenBracket = 12,
    CloseBracket = 13,
    OpenCurly = 14,
    CloseCurly = 15
}
export interface IToken extends ITextRange {
    readonly type: TokenType;
}
export declare enum TokenizerMode {
    CommentsAndStrings = 0,
    Full = 1
}
export interface ITokenizer {
    tokenize(text: string): ITextRangeCollection<IToken>;
    tokenize(text: string, start: number, length: number, mode: TokenizerMode): ITextRangeCollection<IToken>;
}
