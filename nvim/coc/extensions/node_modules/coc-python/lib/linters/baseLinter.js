// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const types_1 = require("../common/application/types");
const constants_1 = require("../common/constants");
const types_2 = require("../common/process/types");
const types_3 = require("../common/types");
const errorHandler_1 = require("./errorHandlers/errorHandler");
const types_4 = require("./types");
const string_1 = require("../common/string");
const function_1 = require("../common/function");
// tslint:disable-next-line:no-require-imports no-var-requires no-any
const namedRegexp = require('named-js-regexp');
// Allow negative column numbers (https://github.com/PyCQA/pylint/issues/1822)
const REGEX = '(?<line>\\d+),(?<column>-?\\d+),(?<type>\\w+),(?<code>\\w\\d+):(?<message>.*)\\r?(\\n|$)';
function matchNamedRegEx(data, regex) {
    const compiledRegexp = namedRegexp(regex, 'g');
    const rawMatch = compiledRegexp.exec(data);
    if (rawMatch !== null) {
        return rawMatch.groups();
    }
    return undefined;
}
exports.matchNamedRegEx = matchNamedRegEx;
function parseLine(line, regex, linterID, colOffset = 0) {
    const match = matchNamedRegEx(line, regex);
    if (!match) {
        return;
    }
    // tslint:disable-next-line:no-any
    match.line = Number(match.line);
    // tslint:disable-next-line:no-any
    match.column = Number(match.column);
    return {
        code: match.code,
        message: match.message,
        column: isNaN(match.column) || match.column <= 0 ? 0 : match.column - colOffset,
        line: match.line,
        type: match.type,
        provider: linterID
    };
}
exports.parseLine = parseLine;
class BaseLinter {
    constructor(product, outputChannel, serviceContainer, columnOffset = 0) {
        this.outputChannel = outputChannel;
        this.serviceContainer = serviceContainer;
        this.columnOffset = columnOffset;
        this._info = serviceContainer.get(types_4.ILinterManager).getLinterInfo(product);
        this.errorHandler = new errorHandler_1.ErrorHandler(this.info.product, outputChannel, serviceContainer);
        this.configService = serviceContainer.get(types_3.IConfigurationService);
        this.workspace = serviceContainer.get(types_1.IWorkspaceService);
    }
    get pythonSettings() {
        return this._pythonSettings;
    }
    get info() {
        return this._info;
    }
    async lint(document, cancellation) {
        this._pythonSettings = this.configService.getSettings(coc_nvim_1.Uri.parse(document.uri));
        return this.runLinter(document, cancellation);
    }
    getWorkspaceRootPath(document) {
        return coc_nvim_1.workspace.rootPath;
    }
    get logger() {
        return this.serviceContainer.get(types_3.ILogger);
    }
    // tslint:disable-next-line:no-any
    parseMessagesSeverity(error, categorySeverity) {
        if (categorySeverity[error]) {
            const severityName = categorySeverity[error];
            switch (severityName) {
                case 'Error':
                    return types_4.LintMessageSeverity.Error;
                case 'Hint':
                    return types_4.LintMessageSeverity.Hint;
                case 'Information':
                    return types_4.LintMessageSeverity.Information;
                case 'Warning':
                    return types_4.LintMessageSeverity.Warning;
                default: {
                    if (types_4.LintMessageSeverity[severityName]) {
                        // tslint:disable-next-line:no-any
                        return types_4.LintMessageSeverity[severityName];
                    }
                }
            }
        }
        return types_4.LintMessageSeverity.Information;
    }
    async run(args, document, cancellation, regEx = REGEX) {
        if (!this.info.isEnabled(coc_nvim_1.Uri.parse(document.uri))) {
            return [];
        }
        const executionInfo = this.info.getExecutionInfo(args, coc_nvim_1.Uri.parse(document.uri));
        const cwd = this.getWorkspaceRootPath(document);
        const pythonToolsExecutionService = this.serviceContainer.get(types_2.IPythonToolExecutionService);
        try {
            const result = await pythonToolsExecutionService.exec(executionInfo, { cwd, token: cancellation, mergeStdOutErr: false }, coc_nvim_1.Uri.parse(document.uri));
            this.displayLinterResultHeader(result.stdout);
            return await this.parseMessages(result.stdout, document, cancellation, regEx);
        }
        catch (error) {
            await this.handleError(error, coc_nvim_1.Uri.parse(document.uri), executionInfo);
            return [];
        }
    }
    async parseMessages(output, _document, _token, regEx) {
        const outputLines = string_1.splitLines(output, { removeEmptyEntries: false, trim: false });
        return this.parseLines(outputLines, regEx);
    }
    async handleError(error, resource, execInfo) {
        if (constants_1.isTestExecution()) {
            this.errorHandler.handleError(error, resource, execInfo)
                .catch(function_1.emptyFn);
        }
        else {
            this.errorHandler.handleError(error, resource, execInfo)
                .catch(this.logger.logError.bind(this, 'Error in errorHandler.handleError'))
                .catch(function_1.emptyFn);
        }
    }
    parseLine(line, regEx) {
        return parseLine(line, regEx, this.info.id, this.columnOffset);
    }
    parseLines(outputLines, regEx) {
        const messages = [];
        for (const line of outputLines) {
            try {
                const msg = this.parseLine(line, regEx);
                if (msg) {
                    messages.push(msg);
                    if (messages.length >= this.pythonSettings.linting.maxNumberOfProblems) {
                        break;
                    }
                }
            }
            catch (ex) {
                this.logger.logError(`Linter '${this.info.id}' failed to parse the line '${line}.`, ex);
            }
        }
        return messages;
    }
    displayLinterResultHeader(data) {
        this.outputChannel.append(`${'#'.repeat(10)}Linting Output - ${this.info.id}${'#'.repeat(10)}\n`);
        this.outputChannel.append(data);
    }
}
exports.BaseLinter = BaseLinter;
//# sourceMappingURL=baseLinter.js.map