// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const types_1 = require("../common/application/types");
const constants_1 = require("../common/constants");
const localize_1 = require("../common/utils/localize");
const types_2 = require("./types");
const string_1 = require("../common/string");
class LinterCommands {
    constructor(serviceContainer) {
        this.serviceContainer = serviceContainer;
        this.disposables = [];
        this.linterManager = this.serviceContainer.get(types_2.ILinterManager);
        const commandManager = this.serviceContainer.get(types_1.ICommandManager);
        commandManager.registerCommand(constants_1.Commands.Set_Linter, this.setLinterAsync.bind(this));
        commandManager.registerCommand(constants_1.Commands.Enable_Linter, this.enableLintingAsync.bind(this));
        commandManager.registerCommand(constants_1.Commands.Run_Linter, this.runLinting.bind(this));
    }
    dispose() {
        this.disposables.forEach(disposable => disposable.dispose());
    }
    async setLinterAsync() {
        const linters = this.linterManager.getAllLinterInfos();
        const suggestions = linters.map(x => x.id).sort();
        const linterList = ['Disable Linting', ...suggestions];
        const activeLinters = await this.linterManager.getActiveLinters(true, this.settingsUri);
        let current;
        switch (activeLinters.length) {
            case 0:
                current = 'none';
                break;
            case 1:
                current = activeLinters[0].id;
                break;
            default:
                current = 'multiple selected';
                break;
        }
        const placeHolder = `current: ${current}`;
        const idx = await coc_nvim_1.workspace.showQuickpick(linterList, placeHolder);
        if (idx !== -1) {
            const selection = linterList[idx];
            if (selection === 'Disable Linting') {
                await this.linterManager.enableLintingAsync(false);
                // sendTelemetryEvent(EventName.SELECT_LINTER, undefined, { enabled: false })
            }
            else {
                const index = linters.findIndex(x => x.id === selection);
                if (activeLinters.length > 1) {
                    const response = await coc_nvim_1.workspace.showPrompt(string_1.format(localize_1.Linters.replaceWithSelectedLinter(), selection));
                    if (!response)
                        return;
                }
                await this.linterManager.setActiveLintersAsync([linters[index].product], this.settingsUri);
            }
        }
    }
    async enableLintingAsync() {
        const options = ['on', 'off'];
        const current = await this.linterManager.isLintingEnabled(true, this.settingsUri) ? options[0] : options[1];
        const idx = await coc_nvim_1.workspace.showQuickpick(options, `current: ${current}`);
        if (idx != -1) {
            const enable = idx == 0;
            await this.linterManager.enableLintingAsync(enable, this.settingsUri);
        }
    }
    runLinting() {
        const engine = this.serviceContainer.get(types_2.ILintingEngine);
        return engine.lintOpenPythonFiles();
    }
    get settingsUri() {
        let doc = coc_nvim_1.workspace.getDocument(coc_nvim_1.workspace.bufnr);
        return doc ? coc_nvim_1.Uri.parse(doc.uri) : undefined;
    }
}
exports.LinterCommands = LinterCommands;
//# sourceMappingURL=linterCommands.js.map