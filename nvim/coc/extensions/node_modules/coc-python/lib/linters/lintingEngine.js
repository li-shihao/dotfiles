// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const inversify_1 = require("inversify");
const minimatch_1 = require("minimatch");
const path_1 = __importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const types_1 = require("../common/application/types");
const constants_1 = require("../common/constants");
const types_2 = require("../common/platform/types");
const types_3 = require("../common/types");
const types_4 = require("../ioc/types");
const provider_1 = require("../jupyter/provider");
const types_5 = require("./types");
const PYTHON = { language: 'python' };
const lintSeverityToVSSeverity = new Map();
lintSeverityToVSSeverity.set(types_5.LintMessageSeverity.Error, vscode_languageserver_protocol_1.DiagnosticSeverity.Error);
lintSeverityToVSSeverity.set(types_5.LintMessageSeverity.Hint, vscode_languageserver_protocol_1.DiagnosticSeverity.Hint);
lintSeverityToVSSeverity.set(types_5.LintMessageSeverity.Information, vscode_languageserver_protocol_1.DiagnosticSeverity.Information);
lintSeverityToVSSeverity.set(types_5.LintMessageSeverity.Warning, vscode_languageserver_protocol_1.DiagnosticSeverity.Warning);
let LintingEngine = class LintingEngine {
    constructor(serviceContainer) {
        this.serviceContainer = serviceContainer;
        this.pendingLintings = new Map();
        this.documentHasJupyterCodeCells = (_a, _b) => Promise.resolve(false);
        this.documents = serviceContainer.get(types_1.IDocumentManager);
        this.configurationService = serviceContainer.get(types_3.IConfigurationService);
        this.outputChannel = serviceContainer.get(types_3.IOutputChannel, constants_1.STANDARD_OUTPUT_CHANNEL);
        this.linterManager = serviceContainer.get(types_5.ILinterManager);
        this.fileSystem = serviceContainer.get(types_2.IFileSystem);
        this.diagnosticCollection = coc_nvim_1.languages.createDiagnosticCollection('python');
    }
    get diagnostics() {
        return this.diagnosticCollection;
    }
    clearDiagnostics(document) {
        if (this.diagnosticCollection.has(document.uri)) {
            this.diagnosticCollection.delete(document.uri);
        }
    }
    async lintOpenPythonFiles() {
        this.diagnosticCollection.clear();
        const promises = this.documents.textDocuments.map(async (document) => this.lintDocument(document));
        await Promise.all(promises);
        return this.diagnosticCollection;
    }
    async lintDocument(document) {
        this.diagnosticCollection.set(document.uri, []);
        // Check if we need to lint this document
        if (!await this.shouldLintDocument(document)) {
            return;
        }
        const fsPath = coc_nvim_1.Uri.parse(document.uri).fsPath;
        if (this.pendingLintings.has(fsPath)) {
            this.pendingLintings.get(fsPath).cancel();
            this.pendingLintings.delete(fsPath);
        }
        const cancelToken = new vscode_languageserver_protocol_1.CancellationTokenSource();
        cancelToken.token.onCancellationRequested(() => {
            if (this.pendingLintings.has(fsPath)) {
                this.pendingLintings.delete(fsPath);
            }
        });
        this.pendingLintings.set(fsPath, cancelToken);
        const activeLinters = await this.linterManager.getActiveLinters(false, coc_nvim_1.Uri.parse(document.uri));
        const promises = activeLinters
            .map(async (info) => {
            const linter = await this.linterManager.createLinter(info.product, this.outputChannel, this.serviceContainer, coc_nvim_1.Uri.parse(document.uri));
            const promise = linter.lint(document, cancelToken.token);
            return promise;
        });
        const hasJupyterCodeCells = await this.documentHasJupyterCodeCells(document, cancelToken.token);
        // linters will resolve asynchronously - keep a track of all
        // diagnostics reported as them come in.
        let diagnostics = [];
        const settings = this.configurationService.getSettings(coc_nvim_1.Uri.parse(document.uri));
        for (const p of promises) {
            const msgs = await p;
            if (cancelToken.token.isCancellationRequested) {
                break;
            }
            if (this.isDocumentOpen(document.uri)) {
                let doc = coc_nvim_1.workspace.getDocument(document.uri);
                // Build the message and suffix the message with the name of the linter used.
                for (const m of msgs) {
                    // Ignore magic commands from jupyter.
                    if (hasJupyterCodeCells && doc.getline(m.line - 1).trim().startsWith('%') &&
                        (m.code === constants_1.LinterErrors.pylint.InvalidSyntax ||
                            m.code === constants_1.LinterErrors.prospector.InvalidSyntax ||
                            m.code === constants_1.LinterErrors.flake8.InvalidSyntax)) {
                        continue;
                    }
                    diagnostics.push(this.createDiagnostics(m, document));
                }
                // Limit the number of messages to the max value.
                diagnostics = diagnostics.filter((_value, index) => index <= settings.linting.maxNumberOfProblems);
            }
        }
        // Set all diagnostics found in this pass, as this method always clears existing diagnostics.
        this.diagnosticCollection.set(document.uri, diagnostics);
    }
    // tslint:disable-next-line:no-any
    async linkJupyterExtension(jupyter) {
        if (!jupyter) {
            return;
        }
        if (!jupyter.isActive) {
            await jupyter.activate();
        }
        // tslint:disable-next-line:no-unsafe-any
        jupyter.exports.registerLanguageProvider(PYTHON.language, new provider_1.JupyterProvider());
        // tslint:disable-next-line:no-unsafe-any
        this.documentHasJupyterCodeCells = jupyter.exports.hasCodeCells;
    }
    isDocumentOpen(uri) {
        return coc_nvim_1.workspace.getDocument(uri) != null;
    }
    createDiagnostics(message, _document) {
        const position = vscode_languageserver_protocol_1.Position.create(message.line - 1, message.column);
        const range = vscode_languageserver_protocol_1.Range.create(position, position);
        const severity = lintSeverityToVSSeverity.get(message.severity);
        const diagnostic = vscode_languageserver_protocol_1.Diagnostic.create(range, message.message, severity);
        diagnostic.code = message.code;
        diagnostic.source = message.provider;
        return diagnostic;
    }
    async shouldLintDocument(document) {
        if (!await this.linterManager.isLintingEnabled(false, coc_nvim_1.Uri.parse(document.uri))) {
            this.diagnosticCollection.set(document.uri, []);
            return false;
        }
        if (document.languageId !== PYTHON.language) {
            return false;
        }
        // const workspaceFolder = this.workspace.getWorkspaceFolder(document.uri)
        // const workspaceRootPath = (workspaceFolder && typeof workspaceFolder.uri.fsPath === 'string') ? workspaceFolder.uri.fsPath : undefined
        const relativeFileName = path_1.default.relative(coc_nvim_1.workspace.rootPath, coc_nvim_1.Uri.parse(document.uri).fsPath);
        const settings = this.configurationService.getSettings(coc_nvim_1.Uri.parse(document.uri));
        // { dot: true } is important so dirs like `.venv` will be matched by globs
        const ignoreMinmatches = settings.linting.ignorePatterns.map(pattern => new minimatch_1.Minimatch(pattern, { dot: true }));
        if (ignoreMinmatches.some(matcher => matcher.match(coc_nvim_1.Uri.parse(document.uri).fsPath) || matcher.match(relativeFileName))) {
            return false;
        }
        let u = coc_nvim_1.Uri.parse(document.uri);
        if (u.scheme !== 'file' || !u.fsPath) {
            return false;
        }
        return this.fileSystem.fileExists(u.fsPath);
    }
};
LintingEngine = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(types_4.IServiceContainer))
], LintingEngine);
exports.LintingEngine = LintingEngine;
//# sourceMappingURL=lintingEngine.js.map