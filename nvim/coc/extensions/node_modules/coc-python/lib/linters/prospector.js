"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const coc_nvim_1 = require("coc.nvim");
const types_1 = require("../common/types");
const baseLinter_1 = require("./baseLinter");
class Prospector extends baseLinter_1.BaseLinter {
    constructor(outputChannel, serviceContainer) {
        super(types_1.Product.prospector, outputChannel, serviceContainer);
    }
    async runLinter(document, cancellation) {
        const cwd = this.getWorkspaceRootPath(document);
        const relativePath = path_1.default.relative(cwd, coc_nvim_1.Uri.parse(document.uri).fsPath);
        return this.run(['--absolute-paths', '--output-format=json', relativePath], document, cancellation);
    }
    async parseMessages(output, _document, _token, _regEx) {
        let parsedData;
        try {
            parsedData = JSON.parse(output);
        }
        catch (ex) {
            this.outputChannel.appendLine(`${'#'.repeat(10)}Linting Output - ${this.info.id}${'#'.repeat(10)}`);
            this.outputChannel.append(output);
            this.logger.logError('Failed to parse Prospector output', ex);
            return [];
        }
        return parsedData.messages
            .filter((_value, index) => index <= this.pythonSettings.linting.maxNumberOfProblems)
            .map(msg => {
            const lineNumber = msg.location.line === null || isNaN(msg.location.line) ? 1 : msg.location.line;
            return {
                code: msg.code,
                message: msg.message,
                column: msg.location.character,
                line: lineNumber,
                type: msg.code,
                provider: `${this.info.id} - ${msg.source}`
            };
        });
    }
}
exports.Prospector = Prospector;
//# sourceMappingURL=prospector.js.map