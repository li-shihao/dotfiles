"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const coc_nvim_1 = require("coc.nvim");
const types_1 = require("../common/types");
const constants_1 = require("./../common/platform/constants");
const baseLinter_1 = require("./baseLinter");
const types_2 = require("./types");
class PyDocStyle extends baseLinter_1.BaseLinter {
    constructor(outputChannel, serviceContainer) {
        super(types_1.Product.pydocstyle, outputChannel, serviceContainer);
    }
    async runLinter(document, cancellation) {
        const messages = await this.run([coc_nvim_1.Uri.parse(document.uri).fsPath], document, cancellation);
        // All messages in pep8 are treated as warnings for now.
        messages.forEach(msg => {
            msg.severity = types_2.LintMessageSeverity.Warning;
        });
        return messages;
    }
    async parseMessages(output, document, _token, _regEx) {
        let outputLines = output.split(/\r?\n/g);
        const baseFileName = path.basename(coc_nvim_1.Uri.parse(document.uri).fsPath);
        // Remember, the first line of the response contains the file name and line number, the next line contains the error message.
        // So we have two lines per message, hence we need to take lines in pairs.
        const maxLines = this.pythonSettings.linting.maxNumberOfProblems * 2;
        // First line is almost always empty.
        const oldOutputLines = outputLines.filter(line => line.length > 0);
        outputLines = [];
        for (let counter = 0; counter < oldOutputLines.length / 2; counter += 1) {
            outputLines.push(oldOutputLines[2 * counter] + oldOutputLines[(2 * counter) + 1]);
        }
        const doc = coc_nvim_1.workspace.getDocument(document.uri);
        return outputLines
            .filter((value, index) => index < maxLines && value.indexOf(':') >= 0)
            .map(line => {
            // Windows will have a : after the drive letter (e.g. c:\).
            if (constants_1.IS_WINDOWS) {
                return line.substring(line.indexOf(`${baseFileName}:`) + baseFileName.length + 1).trim();
            }
            return line.substring(line.indexOf(':') + 1).trim();
        })
            // Iterate through the lines (skipping the messages).
            // So, just iterate the response in pairs.
            .map(line => {
            try {
                if (line.trim().length === 0) {
                    return;
                }
                const lineNumber = parseInt(line.substring(0, line.indexOf(' ')), 10);
                const part = line.substring(line.indexOf(':') + 1).trim();
                const code = part.substring(0, part.indexOf(':')).trim();
                const message = part.substring(part.indexOf(':') + 1).trim();
                const sourceLine = doc.getline(lineNumber - 1);
                const trmmedSourceLine = sourceLine.trim();
                const sourceStart = sourceLine.indexOf(trmmedSourceLine);
                // tslint:disable-next-line:no-object-literal-type-assertion
                return {
                    code,
                    message,
                    column: sourceStart,
                    line: lineNumber,
                    type: '',
                    provider: this.info.id
                };
            }
            catch (ex) {
                this.logger.logError(`Failed to parse pydocstyle line '${line}'`, ex);
                return;
            }
        })
            .filter(item => item !== undefined)
            .map(item => item);
    }
}
exports.PyDocStyle = PyDocStyle;
//# sourceMappingURL=pydocstyle.js.map