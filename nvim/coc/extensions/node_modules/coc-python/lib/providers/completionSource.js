// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../common/types");
const proxy = __importStar(require("./jediProxy"));
const providerUtilities_1 = require("./providerUtilities");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const coc_nvim_1 = require("coc.nvim");
class DocumentPosition {
    constructor(document, position) {
        this.document = document;
        this.position = position;
    }
    static fromObject(item) {
        // tslint:disable-next-line:no-any
        return item._documentPosition;
    }
    attachTo(item) {
        // tslint:disable-next-line:no-any
        item._documentPosition = this;
    }
}
class CompletionSource {
    constructor(jediFactory, serviceContainer, itemInfoSource) {
        this.serviceContainer = serviceContainer;
        this.itemInfoSource = itemInfoSource;
        this.jediFactory = jediFactory;
    }
    async getVsCodeCompletionItems(document, position, token) {
        const result = await this.getCompletionResult(document, position, token);
        if (result === undefined) {
            return Promise.resolve([]);
        }
        return this.toVsCodeCompletions(new DocumentPosition(document, position), result, coc_nvim_1.Uri.parse(document.uri));
    }
    async getDocumentation(completionItem, token) {
        const documentPosition = DocumentPosition.fromObject(completionItem);
        if (documentPosition === undefined) {
            return;
        }
        const doc = coc_nvim_1.workspace.getDocument(coc_nvim_1.workspace.bufnr);
        // Supply hover source with simulated document text where item in question was 'already typed'.
        const document = doc.textDocument;
        const position = documentPosition.position;
        const wordRange = doc.getWordRangeAtPosition(position);
        const leadingRange = wordRange !== undefined
            ? vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(0, 0), wordRange.start)
            : vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(0, 0), position);
        const itemString = completionItem.label;
        const sourceText = `${document.getText(leadingRange)}${itemString}`;
        const range = vscode_languageserver_protocol_1.Range.create(leadingRange.end, { line: leadingRange.end.line, character: leadingRange.end.character + itemString.length });
        return this.itemInfoSource.getItemInfoFromText(coc_nvim_1.Uri.parse(document.uri), coc_nvim_1.Uri.parse(doc.uri).fsPath, range, sourceText, token);
    }
    async getCompletionResult(document, position, token) {
        if (position.character < 0 ||
            providerUtilities_1.isPositionInsideStringOrComment(document, position)) {
            return undefined;
        }
        const type = proxy.CommandType.Completions;
        const columnIndex = position.character;
        const source = document.getText();
        const cmd = {
            command: type,
            fileName: coc_nvim_1.Uri.parse(document.uri).fsPath,
            columnIndex,
            lineIndex: position.line,
            source
        };
        return this.jediFactory.getJediProxyHandler(coc_nvim_1.Uri.parse(document.uri)).sendCommand(cmd, token);
    }
    toVsCodeCompletions(documentPosition, data, resource) {
        return data && data.items.length > 0 ? data.items.map(item => this.toVsCodeCompletion(documentPosition, item, resource)) : [];
    }
    toVsCodeCompletion(documentPosition, item, resource) {
        const completionItem = vscode_languageserver_protocol_1.CompletionItem.create(item.text);
        completionItem.kind = item.type;
        const configurationService = this.serviceContainer.get(types_1.IConfigurationService);
        const pythonSettings = configurationService.getSettings(resource);
        if (pythonSettings.autoComplete.addBrackets === true &&
            (item.kind === vscode_languageserver_protocol_1.SymbolKind.Function || item.kind === vscode_languageserver_protocol_1.SymbolKind.Method)) {
            // tslint:disable-next-line: deprecation
            completionItem.insertText = `${item.text}($0)`;
            completionItem.insertTextFormat = vscode_languageserver_protocol_1.InsertTextFormat.Snippet;
        }
        // Ensure the built in members are at the bottom.
        completionItem.sortText = (completionItem.label.startsWith('__') ? 'z' : (completionItem.label.startsWith('_') ? 'y' : '__')) + completionItem.label;
        documentPosition.attachTo(completionItem);
        return completionItem;
    }
}
exports.CompletionSource = CompletionSource;
//# sourceMappingURL=completionSource.js.map