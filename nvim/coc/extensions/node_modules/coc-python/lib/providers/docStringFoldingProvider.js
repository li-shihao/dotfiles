// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const coc_nvim_1 = require("coc.nvim");
const iterableTextRange_1 = require("../language/iterableTextRange");
const types_1 = require("../language/types");
const providerUtilities_1 = require("./providerUtilities");
class DocStringFoldingProvider {
    provideFoldingRanges(document, _context, _token) {
        return this.getFoldingRanges(document);
    }
    getFoldingRanges(document) {
        let doc = coc_nvim_1.workspace.getDocument(document.uri);
        let position = vscode_languageserver_protocol_1.Position.create(doc.lineCount - 1, doc.getline(doc.lineCount - 1).length);
        const tokenCollection = providerUtilities_1.getDocumentTokens(document, position, types_1.TokenizerMode.CommentsAndStrings);
        const tokens = new iterableTextRange_1.IterableTextRange(tokenCollection);
        const docStringRanges = [];
        const commentRanges = [];
        for (const token of tokens) {
            const docstringRange = this.getDocStringFoldingRange(document, token);
            if (docstringRange) {
                docStringRanges.push(docstringRange);
                continue;
            }
            const commentRange = this.getSingleLineCommentRange(document, token);
            if (commentRange) {
                this.buildMultiLineCommentRange(commentRange, commentRanges);
            }
        }
        this.removeLastSingleLineComment(commentRanges);
        return docStringRanges.concat(commentRanges);
    }
    buildMultiLineCommentRange(commentRange, commentRanges) {
        if (commentRanges.length === 0) {
            commentRanges.push(commentRange);
            return;
        }
        const previousComment = commentRanges[commentRanges.length - 1];
        if (previousComment.endLine + 1 === commentRange.startLine) {
            previousComment.endLine = commentRange.endLine;
            return;
        }
        if (previousComment.startLine === previousComment.endLine) {
            commentRanges[commentRanges.length - 1] = commentRange;
            return;
        }
        commentRanges.push(commentRange);
    }
    removeLastSingleLineComment(commentRanges) {
        // Remove last comment folding range if its a single line entry.
        if (commentRanges.length === 0) {
            return;
        }
        const lastComment = commentRanges[commentRanges.length - 1];
        if (lastComment.startLine === lastComment.endLine) {
            commentRanges.pop();
        }
    }
    getDocStringFoldingRange(document, token) {
        if (token.type !== types_1.TokenType.String) {
            return;
        }
        const doc = coc_nvim_1.workspace.getDocument(document.uri);
        const startPosition = document.positionAt(token.start);
        const endPosition = document.positionAt(token.end);
        if (startPosition.line === endPosition.line) {
            return;
        }
        const startLine = doc.getline(startPosition.line);
        if (startLine.match(/^\s*/)[0].length !== startPosition.character) {
            return;
        }
        const startIndex1 = startLine.indexOf('\'\'\'');
        const startIndex2 = startLine.indexOf('"""');
        if (startIndex1 !== startPosition.character && startIndex2 !== startPosition.character) {
            return;
        }
        const range = vscode_languageserver_protocol_1.Range.create(startPosition, endPosition);
        return vscode_languageserver_protocol_1.FoldingRange.create(range.start.line, range.end.line);
    }
    getSingleLineCommentRange(document, token) {
        if (token.type !== types_1.TokenType.Comment) {
            return;
        }
        const doc = coc_nvim_1.workspace.getDocument(document.uri);
        const startPosition = document.positionAt(token.start);
        const endPosition = document.positionAt(token.end);
        if (startPosition.line !== endPosition.line) {
            return;
        }
        let idx = doc.getline(startPosition.line).match(/^\s*/)[0].length;
        if (idx !== startPosition.character) {
            return;
        }
        const range = vscode_languageserver_protocol_1.Range.create(startPosition, endPosition);
        return vscode_languageserver_protocol_1.FoldingRange.create(range.start.line, range.end.line, 0, 0, vscode_languageserver_protocol_1.FoldingRangeKind.Comment);
    }
}
exports.DocStringFoldingProvider = DocStringFoldingProvider;
//# sourceMappingURL=docStringFoldingProvider.js.map