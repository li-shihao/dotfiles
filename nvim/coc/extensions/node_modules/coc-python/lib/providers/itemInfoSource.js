// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const os_1 = require("os");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const restTextConverter_1 = require("../common/markdown/restTextConverter");
const proxy = __importStar(require("./jediProxy"));
class LanguageItemInfo {
    constructor(tooltip, detail, signature) {
        this.tooltip = tooltip;
        this.detail = detail;
        this.signature = signature;
    }
}
exports.LanguageItemInfo = LanguageItemInfo;
class ItemInfoSource {
    constructor(jediFactory) {
        this.jediFactory = jediFactory;
        this.textConverter = new restTextConverter_1.RestTextConverter();
    }
    async getItemInfoFromText(documentUri, fileName, range, sourceText, token) {
        const result = await this.getHoverResultFromTextRange(documentUri, fileName, range, sourceText, token);
        if (!result || !result.items.length) {
            return;
        }
        return this.getItemInfoFromHoverResult(result, '');
    }
    async getItemInfoFromDocument(document, position, token) {
        const doc = coc_nvim_1.workspace.getDocument(document.uri);
        const range = doc.getWordRangeAtPosition(position);
        if (!range || (range.start.line == range.end.line && range.start.character == range.end.character)) {
            return;
        }
        const result = await this.getHoverResultFromDocument(document, position, token);
        if (!result || !result.items.length) {
            return;
        }
        const word = document.getText(range);
        return this.getItemInfoFromHoverResult(result, word);
    }
    async getHoverResultFromDocument(document, position, token) {
        const doc = coc_nvim_1.workspace.getDocument(document.uri);
        if (doc.getline(position.line).match(/^\s*\/\//)) {
            return;
        }
        const range = doc.getWordRangeAtPosition(position);
        if (!range || (range.start.line == range.end.line && range.start.character == range.end.character)) {
            return;
        }
        return this.getHoverResultFromDocumentRange(document, range, token);
    }
    async getHoverResultFromDocumentRange(document, range, token) {
        const doc = coc_nvim_1.workspace.getDocument(document.uri);
        const cmd = {
            command: proxy.CommandType.Hover,
            fileName: coc_nvim_1.Uri.parse(document.uri).fsPath,
            columnIndex: range.end.character,
            lineIndex: range.end.line
        };
        if (doc.dirty) {
            cmd.source = document.getText();
        }
        return this.jediFactory.getJediProxyHandler(coc_nvim_1.Uri.parse(document.uri)).sendCommand(cmd, token);
    }
    async getHoverResultFromTextRange(documentUri, fileName, range, sourceText, token) {
        const cmd = {
            command: proxy.CommandType.Hover,
            fileName,
            columnIndex: range.end.character,
            lineIndex: range.end.line,
            source: sourceText
        };
        return this.jediFactory.getJediProxyHandler(documentUri).sendCommand(cmd, token);
    }
    getItemInfoFromHoverResult(data, currentWord) {
        const infos = [];
        data.items.forEach(item => {
            const signature = this.getSignature(item, currentWord);
            let tooltip = { kind: 'markdown', value: '' };
            if (item.docstring) {
                let lines = item.docstring.split(/\r?\n/);
                // If the docstring starts with the signature, then remove those lines from the docstring.
                if (lines.length > 0 && item.signature.indexOf(lines[0]) === 0) {
                    lines.shift();
                    const endIndex = lines.findIndex(line => item.signature.endsWith(line));
                    if (endIndex >= 0) {
                        lines = lines.filter((_line, index) => index > endIndex);
                    }
                }
                if (lines.length > 0 && currentWord.length > 0 && item.signature.startsWith(currentWord) && lines[0].startsWith(currentWord) && lines[0].endsWith(')')) {
                    lines.shift();
                }
                if (signature.length > 0) {
                    tooltip.value = tooltip.value + '\n' + (['```python', signature, '```', ''].join(os_1.EOL));
                }
                const description = this.textConverter.toMarkdown(lines.join(os_1.EOL));
                const invalid = description.indexOf('\n') == -1 && description.startsWith('\\');
                if (!invalid)
                    tooltip.value = tooltip.value + description;
                infos.push(new LanguageItemInfo(tooltip, item.description, signature));
                return;
            }
            if (item.description) {
                if (signature.length > 0) {
                    tooltip.value = tooltip.value + '\n' + (['```python', signature, '```', ''].join(os_1.EOL));
                }
                const description = this.textConverter.toMarkdown(item.description);
                tooltip.value = tooltip.value + '\n' + description;
                infos.push(new LanguageItemInfo(tooltip, item.description, signature));
                return;
            }
            if (item.text) { // Most probably variable type
                const code = currentWord && currentWord.length > 0
                    ? `${currentWord}: ${item.text}`
                    : item.text;
                tooltip.value = tooltip.value + '\n' + (['```python', code, '```', ''].join(os_1.EOL));
                infos.push(new LanguageItemInfo(tooltip, '', ''));
            }
        });
        return infos;
    }
    getSignature(item, currentWord) {
        let { signature } = item;
        switch (item.kind) {
            case vscode_languageserver_protocol_1.SymbolKind.Constructor:
            case vscode_languageserver_protocol_1.SymbolKind.Function:
            case vscode_languageserver_protocol_1.SymbolKind.Method: {
                signature = `def ${signature}`;
                break;
            }
            case vscode_languageserver_protocol_1.SymbolKind.Class: {
                signature = `class ${signature}`;
                break;
            }
            case vscode_languageserver_protocol_1.SymbolKind.Module: {
                if (signature.length > 0) {
                    signature = `module ${signature}`;
                }
                break;
            }
            default: {
                signature = typeof item.text === 'string' && item.text.length > 0 ? item.text : currentWord;
            }
        }
        return signature;
    }
}
exports.ItemInfoSource = ItemInfoSource;
//# sourceMappingURL=itemInfoSource.js.map