'use strict';
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const defProvider = __importStar(require("./definitionProvider"));
class PythonObjectDefinitionProvider {
    constructor(jediFactory) {
        this._defProvider = new defProvider.PythonDefinitionProvider(jediFactory);
    }
    async goToObjectDefinition() {
        const pathDef = await this.getObjectDefinition();
        if (typeof pathDef !== 'string' || pathDef.length === 0) {
            return;
        }
        const parts = pathDef.split('.');
        let source = '';
        let startColumn = 0;
        if (parts.length === 1) {
            source = `import ${parts[0]}`;
            startColumn = 'import '.length;
        }
        else {
            const mod = parts.shift();
            source = `from ${mod} import ${parts.join('.')}`;
            startColumn = `from ${mod} import `.length;
        }
        const range = vscode_languageserver_protocol_1.Range.create(0, startColumn, 0, source.length - 1);
        // tslint:disable-next-line:no-any
        const doc = {
            fileName: 'test.py',
            lineAt: (_line) => {
                return { text: source };
            },
            getWordRangeAtPosition: (_position) => range,
            isDirty: true,
            getText: () => source
        };
        const tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        const defs = await this._defProvider.provideDefinition(doc, range.start, tokenSource.token);
        if (defs === null) {
            coc_nvim_1.workspace.showMessage(`Definition not found for '${pathDef}'`, 'warning');
            return;
        }
        let uri;
        let lineNumber;
        if (Array.isArray(defs) && defs.length > 0) {
            uri = defs[0].uri;
            lineNumber = defs[0].range.start.line;
        }
        if (defs && !Array.isArray(defs) && defs.uri) {
            uri = defs.uri;
            lineNumber = defs.range.start.line;
        }
        if (uri) {
            await coc_nvim_1.workspace.jumpTo(uri, vscode_languageserver_protocol_1.Position.create(lineNumber, 0));
        }
        else {
            coc_nvim_1.workspace.showMessage(`Definition not found for '${pathDef}'`, 'warning');
        }
    }
    intputValidation(value) {
        if (typeof value !== 'string') {
            return '';
        }
        value = value.trim();
        if (value.length === 0) {
            return '';
        }
        return value;
    }
    async getObjectDefinition() {
        return coc_nvim_1.workspace.requestInput('Enter Object path').then(res => {
            return this.intputValidation(res);
        });
    }
}
exports.PythonObjectDefinitionProvider = PythonObjectDefinitionProvider;
function activateGoToObjectDefinitionProvider(jediFactory) {
    const def = new PythonObjectDefinitionProvider(jediFactory);
    const commandRegistration = coc_nvim_1.commands.registerCommand('python.goToPythonObject', () => def.goToObjectDefinition());
    return [def, commandRegistration];
}
exports.activateGoToObjectDefinitionProvider = activateGoToObjectDefinitionProvider;
//# sourceMappingURL=objectDefinitionProvider.js.map