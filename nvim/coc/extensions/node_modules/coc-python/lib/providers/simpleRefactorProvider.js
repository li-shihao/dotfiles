"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const editor_1 = require("../common/editor");
const types_1 = require("../common/types");
const constants_1 = require("../common/constants");
const proxy_1 = require("../refactor/proxy");
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
let installer;
async function checkDocument(uri) {
    let doc = coc_nvim_1.workspace.getDocument(uri);
    if (!doc)
        return false;
    let modified = await doc.buffer.getOption('modified');
    if (modified != 0) {
        coc_nvim_1.workspace.showMessage('Buffer not saved, please save the buffer first!', 'warning');
        return false;
    }
    return true;
}
function activateSimplePythonRefactorProvider(context, outputChannel, serviceContainer) {
    installer = serviceContainer.get(types_1.IInstaller);
    let disposable = coc_nvim_1.commands.registerCommand(constants_1.Commands.Refactor_Extract_Variable, async (document, range) => {
        let valid = await checkDocument(document.uri);
        if (!valid)
            return;
        extractVariable(context.extensionPath, coc_nvim_1.workspace.getDocument(document.uri), range, 
        // tslint:disable-next-line:no-empty
        outputChannel, serviceContainer).catch(() => { });
    }, null, true);
    context.subscriptions.push(disposable);
    disposable = coc_nvim_1.commands.registerCommand(constants_1.Commands.Refactor_Extract_Method, async (document, range) => {
        let valid = await checkDocument(document.uri);
        if (!valid)
            return;
        extractMethod(context.extensionPath, coc_nvim_1.workspace.getDocument(document.uri), range, 
        // tslint:disable-next-line:no-empty
        outputChannel, serviceContainer).catch(() => { });
    }, null, true);
    context.subscriptions.push(disposable);
    let provider = {
        provideCodeActions: (document, range, actionContext, _token) => {
            let commands = [];
            if (actionContext.only && !actionContext.only.includes(vscode_languageserver_types_1.CodeActionKind.Refactor))
                return [];
            commands.push({
                command: constants_1.Commands.Refactor_Extract_Variable,
                title: 'Extract Variable',
                arguments: [document, range]
            });
            commands.push({
                command: constants_1.Commands.Refactor_Extract_Method,
                title: 'Extract Method',
                arguments: [document, range]
            });
            return commands;
        }
    };
    coc_nvim_1.languages.registerCodeActionProvider(['python'], provider, 'python.simpleRefactor', [vscode_languageserver_types_1.CodeActionKind.Refactor]);
}
exports.activateSimplePythonRefactorProvider = activateSimplePythonRefactorProvider;
// Exported for unit testing
function extractVariable(extensionDir, textEditor, range, 
// tslint:disable-next-line:no-any
outputChannel, serviceContainer) {
    // const workspaceRoot = workspace.rootPath
    const config = coc_nvim_1.workspace.getConfiguration('', textEditor.uri);
    const pythonSettings = config.get('python');
    return validateDocumentForRefactor(textEditor).then(() => {
        const newName = `newvariable${new Date().getMilliseconds().toString()}`;
        const proxy = new proxy_1.RefactorProxy(extensionDir, pythonSettings, coc_nvim_1.Uri.file(coc_nvim_1.workspace.rootPath).toString(), serviceContainer);
        const rename = proxy.extractVariable(textEditor.textDocument, newName, coc_nvim_1.Uri.parse(textEditor.uri).fsPath, range).then(response => {
            return response.results[0].diff;
        });
        return extractName(textEditor, newName, rename, outputChannel);
    });
}
exports.extractVariable = extractVariable;
// Exported for unit testing
function extractMethod(extensionDir, textEditor, range, 
// tslint:disable-next-line:no-any
outputChannel, serviceContainer) {
    const workspaceRoot = coc_nvim_1.workspace.rootPath;
    const pythonSettings = serviceContainer.get(types_1.IConfigurationService).getSettings(coc_nvim_1.Uri.parse(workspaceRoot));
    return validateDocumentForRefactor(textEditor).then(() => {
        const newName = `newmethod${new Date().getMilliseconds().toString()}`;
        const proxy = new proxy_1.RefactorProxy(extensionDir, pythonSettings, workspaceRoot, serviceContainer);
        const rename = proxy.extractMethod(textEditor.textDocument, newName, coc_nvim_1.Uri.parse(textEditor.uri).fsPath, range).then(response => {
            return response.results[0].diff;
        });
        return extractName(textEditor, newName, rename, outputChannel);
    });
}
exports.extractMethod = extractMethod;
// tslint:disable-next-line:no-any
function validateDocumentForRefactor(textEditor) {
    if (!textEditor.dirty) {
        return Promise.resolve();
    }
    // tslint:disable-next-line:no-any
    return new Promise((resolve, reject) => {
        // tslint:disable-next-line: no-floating-promises
        coc_nvim_1.workspace.nvim.command('write').then(() => {
            return resolve();
        }, reject);
    });
}
function extractName(textEditor, newName, 
// tslint:disable-next-line:no-any
renameResponse, outputChannel) {
    let changeStartsAtLine = -1;
    return renameResponse.then(diff => {
        if (diff.length === 0) {
            return [];
        }
        return editor_1.getTextEditsFromPatch(textEditor.getDocumentContent(), diff);
    }).then(edits => {
        edits.forEach(edit => {
            if (changeStartsAtLine === -1 || changeStartsAtLine > edit.range.start.line) {
                changeStartsAtLine = edit.range.start.line;
            }
        });
        return textEditor.applyEdits(coc_nvim_1.workspace.nvim, edits);
    }).then(() => {
        if (changeStartsAtLine >= 0) {
            let newWordPosition;
            for (let lineNumber = changeStartsAtLine; lineNumber < textEditor.lineCount; lineNumber += 1) {
                const line = textEditor.getline(lineNumber);
                const indexOfWord = line.indexOf(newName);
                if (indexOfWord >= 0) {
                    newWordPosition = vscode_languageserver_types_1.Position.create(lineNumber, indexOfWord);
                    break;
                }
            }
            return coc_nvim_1.workspace.jumpTo(textEditor.uri, newWordPosition).then(() => {
                return newWordPosition;
            });
        }
        return null;
    }).then(newWordPosition => {
        if (newWordPosition) {
            return coc_nvim_1.workspace.nvim.command('wa').then(() => {
                // Now that we have selected the new variable, lets invoke the rename command
                return coc_nvim_1.commands.executeCommand('editor.action.rename', textEditor.uri, newWordPosition);
            });
        }
    }).catch(error => {
        if (error === 'Not installed') {
            installer.promptToInstall(types_1.Product.rope, coc_nvim_1.Uri.parse(textEditor.uri))
                // tslint:disable-next-line: no-console
                .catch(ex => console.error('Python Extension: simpleRefactorProvider.promptToInstall', ex));
            return Promise.reject('');
        }
        let errorMessage = `${error}`;
        if (typeof error === 'string') {
            errorMessage = error;
        }
        if (typeof error === 'object' && error.message) {
            errorMessage = error.message;
        }
        outputChannel.appendLine(`${'#'.repeat(10)}Refactor Output${'#'.repeat(10)}`);
        outputChannel.appendLine(`Error in refactoring:\n${errorMessage}`);
        coc_nvim_1.workspace.showMessage(`Cannot perform refactoring using selected element(s). (${errorMessage})`, 'error');
        return Promise.reject(error);
    });
}
//# sourceMappingURL=simpleRefactorProvider.js.map