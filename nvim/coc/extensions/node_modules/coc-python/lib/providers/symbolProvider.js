'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const coc_nvim_1 = require("coc.nvim");
const fs_1 = __importDefault(require("fs"));
const types_1 = require("../common/platform/types");
const async_1 = require("../common/utils/async");
const proxy = __importStar(require("./jediProxy"));
function flattenSymbolTree(tree, uri, containerName = '') {
    const flattened = [];
    const range = vscode_languageserver_protocol_1.Range.create(tree.range.start.line, tree.range.start.character, tree.range.end.line, tree.range.end.character);
    // For whatever reason, the values of VS Code's SymbolKind enum
    // are off-by-one relative to the LSP:
    //  https://microsoft.github.io/language-server-protocol/specification#document-symbols-request-leftwards_arrow_with_hook
    const kind = tree.kind;
    const info = vscode_languageserver_protocol_1.SymbolInformation.create(tree.name, 
    // Type coercion is a bit fuzzy when it comes to enums, so we
    // play it safe by explicitly converting.
    // tslint:disable-next-line:no-any
    vscode_languageserver_protocol_1.SymbolKind[vscode_languageserver_protocol_1.SymbolKind[kind]], range, uri.toString(), containerName);
    flattened.push(info);
    if (tree.children && tree.children.length > 0) {
        // FYI: Jedi doesn't fully-qualify the container name so we
        // don't bother here either.
        // const fullName = `${containerName}.${tree.name}`
        for (const child of tree.children) {
            const flattenedChild = flattenSymbolTree(child, uri, tree.name);
            flattened.push(...flattenedChild);
        }
    }
    return flattened;
}
/**
 * Provides Python symbols to VS Code (from the language server).
 *
 * See:
 *   https://code.visualstudio.com/docs/extensionAPI/vscode-api#DocumentSymbolProvider
 */
class LanguageServerSymbolProvider {
    constructor(languageClient) {
        this.languageClient = languageClient;
    }
    async provideDocumentSymbols(document, token) {
        const uri = document.uri;
        const args = { textDocument: { uri: uri.toString() } };
        const raw = await Promise.resolve(this.languageClient.sendRequest('textDocument/documentSymbol', args, token));
        const symbols = [];
        for (const tree of raw) {
            const flattened = flattenSymbolTree(tree, coc_nvim_1.Uri.parse(uri));
            symbols.push(...flattened);
        }
        return Promise.resolve(symbols);
    }
}
exports.LanguageServerSymbolProvider = LanguageServerSymbolProvider;
/**
 * Provides Python symbols to VS Code (from Jedi).
 *
 * See:
 *   https://code.visualstudio.com/docs/extensionAPI/vscode-api#DocumentSymbolProvider
 */
class JediSymbolProvider {
    constructor(serviceContainer, jediFactory, debounceTimeoutMs = 500) {
        this.jediFactory = jediFactory;
        this.debounceTimeoutMs = debounceTimeoutMs;
        this.debounceRequest = new Map();
        this.fs = serviceContainer.get(types_1.IFileSystem);
    }
    provideDocumentSymbols(document, token) {
        return this.provideDocumentSymbolsThrottled(document, token);
    }
    provideDocumentSymbolsThrottled(document, token) {
        const doc = coc_nvim_1.workspace.getDocument(document.uri);
        const key = `${coc_nvim_1.Uri.parse(document.uri).fsPath}`;
        if (this.debounceRequest.has(key)) {
            const item = this.debounceRequest.get(key);
            clearTimeout(item.timer);
            item.deferred.resolve([]);
        }
        const deferred = async_1.createDeferred();
        const filename = coc_nvim_1.Uri.parse(document.uri).fsPath;
        const timer = setTimeout(() => {
            if (token.isCancellationRequested) {
                return deferred.resolve([]);
            }
            const cmd = {
                command: proxy.CommandType.Symbols,
                fileName: filename,
                columnIndex: 0,
                lineIndex: 0
            };
            if (doc.dirty) {
                cmd.source = document.getText();
            }
            this.jediFactory.getJediProxyHandler(coc_nvim_1.Uri.parse(document.uri)).sendCommand(cmd, token)
                .then(data => this.parseData(document, data))
                .then(items => deferred.resolve(items))
                .catch(ex => deferred.reject(ex));
        }, this.debounceTimeoutMs);
        token.onCancellationRequested(() => {
            clearTimeout(timer);
            deferred.resolve([]);
            this.debounceRequest.delete(key);
        });
        // When a document is not saved on FS, we cannot uniquely identify it, so lets not debounce, but delay the symbol provider.
        if (!fs_1.default.existsSync(filename)) {
            this.debounceRequest.set(key, { timer, deferred });
        }
        return deferred.promise;
    }
    // This does not appear to be used anywhere currently...
    // tslint:disable-next-line:no-unused-variable
    // private provideDocumentSymbolsUnthrottled(document: TextDocument, token: CancellationToken): Thenable<SymbolInformation[]> {
    //     const filename = document.fileName
    //     const cmd: proxy.ICommand<proxy.ISymbolResult> = {
    //         command: proxy.CommandType.Symbols,
    //         fileName: filename,
    //         columnIndex: 0,
    //         lineIndex: 0
    //     }
    //     if (document.isDirty) {
    //         cmd.source = document.getText()
    //     }
    //     return this.jediFactory.getJediProxyHandler<proxy.ISymbolResult>(document.uri).sendCommandNonCancellableCommand(cmd, token)
    //         .then(data => this.parseData(document, data))
    // }
    parseData(document, data) {
        if (data) {
            const symbols = data.definitions.filter(sym => this.fs.arePathsSame(sym.fileName, coc_nvim_1.Uri.parse(document.uri).fsPath));
            return symbols.map(sym => {
                const range = vscode_languageserver_protocol_1.Range.create(sym.range.startLine, sym.range.startColumn, sym.range.endLine, sym.range.endColumn);
                const uri = coc_nvim_1.Uri.file(sym.fileName);
                const location = vscode_languageserver_protocol_1.Location.create(uri.toString(), range);
                return vscode_languageserver_protocol_1.SymbolInformation.create(sym.text, sym.kind, location.range, location.uri, sym.container);
            });
        }
        return [];
    }
}
exports.JediSymbolProvider = JediSymbolProvider;
//# sourceMappingURL=symbolProvider.js.map