// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const fs = __importStar(require("fs"));
const util_1 = require("util");
// tslint:disable:no-require-imports
const setting = 'sourceMapsEnabled';
class SourceMapSupport {
    constructor() {
        this.config = coc_nvim_1.workspace.getConfiguration('python.diagnostics', null);
    }
    async initialize() {
        if (!this.enabled) {
            return;
        }
        // await this.enableSourceMaps(true)
        // const localize = require('./common/utils/localize') as typeof import('./common/utils/localize')
        // // const disable = localize.Diagnostics.disableSourceMaps()
        // // tslint:disable-next-line: no-floating-promises
        // workspace.showPrompt(localize.Diagnostics.warnSourceMaps() + ', disable?').then(res => {
        //   if (res) {
        //     this.disable().catch(emptyFn)
        //   }
        // })
    }
    get enabled() {
        return this.config.get(setting, false);
    }
    async disable() {
        // if (this.enabled) {
        //   this.config.update(setting, false, true)
        // }
        // await this.enableSourceMaps(false)
    }
    async enableSourceMaps(enable) {
        // const extensionSourceFile = path.join(EXTENSION_ROOT_DIR, 'lib', 'index.js')
        // const debuggerSourceFile = path.join(EXTENSION_ROOT_DIR, 'out', 'client', 'debugger', 'debugAdapter', 'main.js')
        // await Promise.all([this.enableSourceMap(enable, extensionSourceFile), this.enableSourceMap(enable, debuggerSourceFile)])
    }
    async enableSourceMap(enable, sourceFile) {
        const sourceMapFile = `${sourceFile}.map`;
        const disabledSourceMapFile = `${sourceFile}.map.disabled`;
        if (enable) {
            await this.rename(disabledSourceMapFile, sourceMapFile);
        }
        else {
            await this.rename(sourceMapFile, disabledSourceMapFile);
        }
    }
    async rename(sourceFile, targetFile) {
        const fsExists = util_1.promisify(fs.exists);
        const fsRename = util_1.promisify(fs.rename);
        if (await fsExists(targetFile)) {
            return;
        }
        await fsRename(sourceFile, targetFile);
    }
}
exports.SourceMapSupport = SourceMapSupport;
function initialize() {
    // if (!workspace.getConfiguration('python.diagnostics', null).get('sourceMapsEnabled', false)) {
    //   new SourceMapSupport().disable().catch(emptyFn)
    //   return
    // }
    // new SourceMapSupport().initialize().catch(_ex => {
    //   console.error('Failed to initialize source map support in extension')
    // })
}
exports.initialize = initialize;
//# sourceMappingURL=sourceMapSupport.js.map