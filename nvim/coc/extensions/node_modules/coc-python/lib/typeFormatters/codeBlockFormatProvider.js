"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const coc_nvim_1 = require("coc.nvim");
class CodeBlockFormatProvider {
    constructor(blockRegExp, previousBlockRegExps, boundaryRegExps) {
        this.blockRegExp = blockRegExp;
        this.previousBlockRegExps = previousBlockRegExps;
        this.boundaryRegExps = boundaryRegExps;
    }
    canProvideEdits(line) {
        return this.blockRegExp.test(line);
    }
    provideEdits(document, position, _ch, options, line) {
        // We can have else for the following blocks:
        // if:
        // elif x:
        // for x in y:
        // while x:
        let doc = coc_nvim_1.workspace.getDocument(document.uri);
        // We need to find a block statement that is less than or equal to this statement block (but not greater)
        for (let lineNumber = position.line - 1; lineNumber >= 0; lineNumber -= 1) {
            const prevLineText = doc.getline(lineNumber);
            // Oops, we've reached a boundary (like the function or class definition)
            // Get out of here
            if (this.boundaryRegExps.some(value => value.test(prevLineText))) {
                return [];
            }
            const blockRegEx = this.previousBlockRegExps.find(value => value.test(prevLineText));
            if (!blockRegEx) {
                continue;
            }
            const startOfBlockInLine = prevLineText.match(/^\s*/)[0].length;
            if (startOfBlockInLine > line.match(/^\s*/)[0].length) {
                continue;
            }
            const startPosition = vscode_languageserver_protocol_1.Position.create(position.line, 0);
            const endPosition = vscode_languageserver_protocol_1.Position.create(position.line, line.match(/^\s*/)[0].length - startOfBlockInLine);
            if (startPosition.line == endPosition.line && startPosition.character == endPosition.character) {
                // current block cannot be at the same level as a preivous block
                continue;
            }
            if (options.insertSpaces) {
                return [
                    vscode_languageserver_protocol_1.TextEdit.del(vscode_languageserver_protocol_1.Range.create(startPosition, endPosition))
                ];
            }
            else {
                // Delete everything before the block and insert the same characters we have in the previous block
                const prefixOfPreviousBlock = prevLineText.substring(0, startOfBlockInLine);
                const startDeletePosition = vscode_languageserver_protocol_1.Position.create(position.line, 0);
                const endDeletePosition = vscode_languageserver_protocol_1.Position.create(position.line, line.match(/^\s*/)[0].length);
                return [
                    vscode_languageserver_protocol_1.TextEdit.del(vscode_languageserver_protocol_1.Range.create(startDeletePosition, endDeletePosition)),
                    vscode_languageserver_protocol_1.TextEdit.insert(startDeletePosition, prefixOfPreviousBlock)
                ];
            }
        }
        return [];
    }
}
exports.CodeBlockFormatProvider = CodeBlockFormatProvider;
//# sourceMappingURL=codeBlockFormatProvider.js.map