"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const coc_nvim_1 = require("coc.nvim");
const lineFormatter_1 = require("../formatters/lineFormatter");
const types_1 = require("../language/types");
const providerUtilities_1 = require("../providers/providerUtilities");
class OnEnterFormatter {
    constructor() {
        this.formatter = new lineFormatter_1.LineFormatter();
    }
    provideOnTypeFormattingEdits(document, position, _ch, _options, _cancellationToken) {
        if (position.line === 0) {
            return [];
        }
        let doc = coc_nvim_1.workspace.getDocument(document.uri);
        // Check case when the entire line belongs to a comment or string
        const prevLine = doc.getline(position.line - 1);
        const range = vscode_languageserver_protocol_1.Range.create(position.line - 1, 0, position.line - 1, prevLine.length);
        const tokens = providerUtilities_1.getDocumentTokens(document, position, types_1.TokenizerMode.CommentsAndStrings);
        const lineStartTokenIndex = tokens.getItemContaining(document.offsetAt(range.start));
        const lineEndTokenIndex = tokens.getItemContaining(document.offsetAt(range.end));
        if (lineStartTokenIndex >= 0 && lineStartTokenIndex === lineEndTokenIndex) {
            const token = tokens.getItemAt(lineStartTokenIndex);
            if (token.type === types_1.TokenType.Semicolon || token.type === types_1.TokenType.String) {
                return [];
            }
        }
        const formatted = this.formatter.formatLine(document, position.line - 1);
        if (formatted === prevLine) {
            return [];
        }
        return [vscode_languageserver_protocol_1.TextEdit.replace(range, formatted)];
    }
}
exports.OnEnterFormatter = OnEnterFormatter;
//# sourceMappingURL=onEnterFormatter.js.map