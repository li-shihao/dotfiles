"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const constants_1 = require("../constants");
class Generator {
    constructor(workspaceFolder, output, appShell, fs, processServiceFactory, configurationService) {
        this.workspaceFolder = workspaceFolder;
        this.output = output;
        this.appShell = appShell;
        this.fs = fs;
        this.processServiceFactory = processServiceFactory;
        this.disposables = [];
        this.optionsFile = path.join(constants_1.EXTENSION_ROOT_DIR, 'resources', 'ctagOptions');
        this.pythonSettings = configurationService.getSettings(workspaceFolder);
    }
    get tagFilePath() {
        return this.pythonSettings.workspaceSymbols.tagFilePath;
    }
    get enabled() {
        return this.pythonSettings.workspaceSymbols.enabled;
    }
    dispose() {
        this.disposables.forEach(d => d.dispose());
    }
    async generateWorkspaceTags() {
        if (!this.pythonSettings.workspaceSymbols.enabled) {
            return;
        }
        return this.generateTags({ directory: this.workspaceFolder.fsPath });
    }
    buildCmdArgs() {
        const exclusions = this.pythonSettings.workspaceSymbols.exclusionPatterns;
        const excludes = exclusions.length === 0 ? [] : exclusions.map(pattern => `--exclude=${pattern}`);
        return [`--options=${this.optionsFile}`, '--languages=Python'].concat(excludes);
    }
    async generateTags(source) {
        const tagFile = path.normalize(this.pythonSettings.workspaceSymbols.tagFilePath);
        const cmd = this.pythonSettings.workspaceSymbols.ctagsPath;
        const args = this.buildCmdArgs();
        let outputFile = tagFile;
        if (source.file && source.file.length > 0) {
            source.directory = path.dirname(source.file);
        }
        if (path.dirname(outputFile) === source.directory) {
            outputFile = path.basename(outputFile);
        }
        const outputDir = path.dirname(outputFile);
        if (!await this.fs.directoryExists(outputDir)) {
            await this.fs.createDirectory(outputDir);
        }
        args.push('-o', outputFile, '.');
        this.output.appendLine(`${'-'.repeat(10)}Generating Tags${'-'.repeat(10)}`);
        this.output.appendLine(`${cmd} ${args.join(' ')}`);
        const promise = new Promise(async (resolve, reject) => {
            try {
                const processService = await this.processServiceFactory.create();
                const result = processService.execObservable(cmd, args, { cwd: source.directory });
                let errorMsg = '';
                result.out.subscribe(output => {
                    if (output.source === 'stderr') {
                        errorMsg += output.out;
                    }
                    this.output.append(output.out);
                }, reject, () => {
                    if (errorMsg.length > 0) {
                        reject(new Error(errorMsg));
                    }
                    else {
                        resolve();
                    }
                });
            }
            catch (ex) {
                reject(ex);
            }
        });
        this.appShell.setStatusBarMessage('Generating Tags', promise);
        await promise;
    }
}
exports.Generator = Generator;
//# sourceMappingURL=generator.js.map