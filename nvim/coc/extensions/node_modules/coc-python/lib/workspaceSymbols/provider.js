'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line:no-var-requires no-require-imports
const flatten = require('lodash/flatten');
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const constants_1 = require("../common/constants");
const parser_1 = require("./parser");
class WorkspaceSymbolProvider {
    constructor(fs, commands, tagGenerators) {
        this.fs = fs;
        this.commands = commands;
        this.tagGenerators = tagGenerators;
    }
    async provideWorkspaceSymbols(query, token) {
        if (this.tagGenerators.length === 0) {
            return [];
        }
        const generatorsWithTagFiles = await Promise.all(this.tagGenerators.map(generator => this.fs.fileExists(generator.tagFilePath)));
        if (generatorsWithTagFiles.filter(exists => exists).length !== this.tagGenerators.length) {
            await Promise.resolve(this.commands.executeCommand(constants_1.Commands.Build_Workspace_Symbols, true, token));
        }
        const generators = [];
        await Promise.all(this.tagGenerators.map(async (generator) => {
            if (await this.fs.fileExists(generator.tagFilePath)) {
                generators.push(generator);
            }
        }));
        const promises = generators
            .filter(generator => generator !== undefined && generator.enabled)
            .map(async (generator) => {
            // load tags
            const items = await parser_1.parseTags(generator.workspaceFolder.fsPath, generator.tagFilePath, query, token);
            if (!Array.isArray(items)) {
                return [];
            }
            // new SymbolInformation(
            // item.symbolName, item.symbolKind, '',
            // new Location(Uri.file(item.fileName), item.position)
            return items.map(item => {
                let range = vscode_languageserver_protocol_1.Range.create(item.position, { line: item.position.line, character: item.position.character + item.symbolName.length });
                return vscode_languageserver_protocol_1.SymbolInformation.create(item.symbolName, item.symbolKind, range, coc_nvim_1.Uri.file(item.fileName).toString());
            });
        });
        const symbols = await Promise.all(promises);
        return flatten(symbols);
    }
}
exports.WorkspaceSymbolProvider = WorkspaceSymbolProvider;
//# sourceMappingURL=provider.js.map